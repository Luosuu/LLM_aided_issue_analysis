{
  "issue_number": 15080,
  "title": "encryption: encryption may corrupt data when partial write",
  "body": "## Bug Report\r\n\r\n<!-- Thanks for your bug report! Don't worry if you can't fill out all the sections. -->\r\n\r\n### What version of TiKV are you using?\r\nCurrent Master.\r\n\r\n### What operating system and CPU are you using?\r\nLinux, x86_64.\r\n\r\n### Steps to reproduce\r\n<!-- If possible, provide a recipe for reproducing the error. A complete runnable program is good. -->\r\nApply the following patch (based on `a5f1a26d3bb5121a845f644b5eebff3d6c041278`):\r\n<details><summary>Patch Content</summary>\r\n\r\n```diff\r\n+++ b/components/encryption/src/io.rs\r\n@@ -525,6 +525,18 @@ mod tests {\r\n         key\r\n     }\r\n \r\n+    struct Throttle<W>(W);\r\n+\r\n+    impl<W: Write> Write for Throttle<W> {\r\n+        fn write(&mut self, buf: &[u8]) -> IoResult<usize> {\r\n+            self.0.write(&buf[..2.min(buf.len())])\r\n+        }\r\n+\r\n+        fn flush(&mut self) -> IoResult<()> {\r\n+            Ok(())\r\n+        }\r\n+    }\r\n+\r\n     #[test]\r\n     fn test_decrypt_encrypted_text() {\r\n         let methods = [\r\n@@ -557,10 +569,10 @@ mod tests {\r\n                 let mut plaintext = vec![0; 1024];\r\n                 OsRng.fill_bytes(&mut plaintext);\r\n                 let buf = Vec::with_capacity(1024);\r\n-                let mut encrypter = EncrypterWriter::new(buf, method, &key, iv).unwrap();\r\n+                let mut encrypter = EncrypterWriter::new(Throttle(buf), method, &key, iv).unwrap();\r\n                 encrypter.write_all(&plaintext).unwrap();\r\n \r\n-                let buf = encrypter.finalize().unwrap();\r\n+                let buf = encrypter.finalize().unwrap().0;\r\n                 // Make sure it's properly encrypted.\r\n                 if method != EncryptionMethod::Plaintext {\r\n                     assert_ne!(buf, plaintext);\r\n```\r\n\r\n</details> \r\n\r\nThen, run the test case `test_decrypt_encrypted_text`.\r\n\r\n### What did you expect?\r\nThe case should pass.\r\n\r\n### What did happened?\r\n```\r\n---- io::tests::test_decrypt_encrypted_text stdout ----\r\nthread 'io::tests::test_decrypt_encrypted_text' panicked at 'assertion failed: `(left == right)`\r\n  left: `[122, 11, 30, 119, 4]`,\r\n right: `[122, 11, 66, 84, 249]`', components/encryption/src/io.rs:589:21\r\n```",
  "state": "closed",
  "created_at": "2023-07-06T06:52:23Z",
  "updated_at": "2023-07-25T13:07:35Z",
  "closed_at": "2023-07-25T13:07:35Z",
  "labels": [
    "type/bug",
    "severity/major",
    "affects-6.1",
    "affects-6.2",
    "affects-6.3",
    "affects-6.4",
    "affects-6.5",
    "affects-6.6",
    "affects-7.0",
    "affects-7.1",
    "affects-7.2"
  ],
  "comments_data": [
    {
      "id": 1623105218,
      "user": "YuJuncen",
      "created_at": "2023-07-06T07:04:57Z",
      "body": "This is probably because some of the block encryption method(includes `AES256`, if I have rightly understood it.) requires the integrity of the encrypted block. But the current `Write` implementation doesn't make sure the integrity of data written.\r\nhttps://github.com/tikv/tikv/blob/a5f1a26d3bb5121a845f644b5eebff3d6c041278/components/encryption/src/io.rs#L333-L338\r\nWhen L337 writes partial of the content, the encrypted block will be partial. The counter of CTR mode may contribute to this problem too. (What if some blocks are skipped? they will be lost in the sequence generated by the counter.) "
    }
  ]
}