{
  "issue_number": 13573,
  "title": "rawkv: correctness violation for raw atomic commands",
  "body": "## Bug Report\r\n\r\n<!-- Thanks for your bug report! Don't worry if you can't fill out all the sections. -->\r\n\r\n### What version of TiKV are you using?\r\n<!-- You can run `tikv-server --version` -->\r\n\r\n‚ùØ target/release/tikv-server -V\r\nTiKV\r\nRelease Version:   6.4.0-alpha\r\nEdition:           Community\r\nGit Commit Hash:   47d8c9e483db762cefe8725abac9f5110e97ae63\r\nGit Commit Branch: master\r\nUTC Build Time:    2022-09-11 10:25:31\r\nRust Version:      rustc 1.64.0-nightly (0f4bcadb4 2022-07-30)\r\nEnable Features:   pprof-fp jemalloc mem-profiling portable sse test-engine-kv-rocksdb test-engine-raft-raft-engine cloud-aws cloud-gcp cloud-azure\r\nProfile:           release\r\n\r\n### What operating system and CPU are you using?\r\n<!-- If you're using Linux, you can run `cat /proc/cpuinfo` -->\r\n\r\nCentOS 7, amd64\r\n\r\n### Steps to reproduce\r\n<!-- If possible, provide a recipe for reproducing the error. A complete runnable program is good. -->\r\n\r\n1. Setup a cluster with 1 x PD, 1 x TiDB, 4 x TiKV, configure as:\r\n```\r\nstorage.api-version: 2\r\nstorage.enable-ttl: true\r\n```\r\n\r\n2. Run test codes as following\r\n```golang\r\nTry(cli.Delete(ctx, key))\r\n\r\n// nil -> value0 -> value1\r\neg, ectx := errgroup.WithContext(ctx)\r\neg.Go(WithGinkgoRecover(func() {\r\n\tTry(cli.Put(ectx, key, value0))\r\n}))\r\neg.Go(WithGinkgoRecover(func() {\r\n\tdoCAS(ectx, cli, key, value0, value1)\r\n}))\r\nTry(eg.Wait())\r\nresult := Try(cli.Get(ctx, key)).([]byte)\r\nExpect(result).Should(Equal(value1), \"key: %v, value0: %v, value1: %v\", string(key), string(value0), string(value1))\r\n```\r\n\r\n```golang\r\nfunc doCAS(ctx context.Context, cli client.Client, key, oldValue, newValue []byte) {\r\n\tvar (\r\n\t\terr       error\r\n\t\tsucceed   bool\r\n\t\tretry     int\r\n\t\tprevValue []byte\r\n\t\telapsed   time.Duration\r\n\t)\r\n\tstart := time.Now()\r\n\tfor !succeed && elapsed < CAS_RETRY_TIMEOUT {\r\n\t\tretry += 1\r\n\t\tif retry%CAS_RETRY_BACKOFF_BATCH == 0 {\r\n\t\t\ttime.Sleep(CAS_RETRY_BACKOFF_DURATION)\r\n\t\t}\r\n\r\n\t\tprevValue, succeed, err = cli.CompareAndSwap(ctx, key, oldValue, newValue)\r\n\t\tExpect(err).To(Succeed())\r\n\t\telapsed = time.Since(start)\r\n\t}\r\n\tExpect(elapsed < CAS_RETRY_TIMEOUT).To(BeTrue(), \"succeed: %v, key: %v, retry: %v, elapsed: %v, oldValue: %v, newValue: %v, prevValue: %v\",\r\n\t\tsucceed, string(key), retry, elapsed, string(oldValue), string(newValue), string(prevValue))\r\n\t}\r\n}\r\n```\r\n\r\n3. Kill one of the `tikv-server` by `KILL -9`\r\n\r\n\r\n### What did you expect?\r\nTest case succeed.\r\n\r\n\r\n### What did happened?\r\nTest case failed on `Expect(result).Should(Equal(value1), ...)`\r\n```\r\n    key: ca0000000399035090, value0: 399035090_0000000000000000000000000000000000000000000000000000000000000000, value1: 399035091_0000000000000000000000000000000000000000000000000000000000000000\r\n    Expected\r\n        <[]uint8 | len:74, cap:80>: 399035090_0000000000000000000000000000000000000000000000000000000000000000\r\n    to equal\r\n        <[]uint8 | len:74, cap:80>: 399035091_0000000000000000000000000000000000000000000000000000000000000000\r\n```",
  "state": "closed",
  "created_at": "2022-10-05T08:02:08Z",
  "updated_at": "2022-10-08T08:35:01Z",
  "closed_at": "2022-10-08T08:35:01Z",
  "labels": [
    "type/bug",
    "severity/critical"
  ],
  "comments_data": [
    {
      "id": 1268123455,
      "user": "pingyu",
      "created_at": "2022-10-05T08:34:20Z",
      "body": "### Conclusion\r\nIt's not a TiKV issue. Raw atomic commands should be used with caution.\r\n\r\n### Analysis\r\nAdd logging on critical path (ref [here](https://github.com/tikv/tikv/compare/47d8c9e483db762cefe8725abac9f5110e97ae63...pingyu:rawkv_atomic_debug)), and got the following:\r\n```sh\r\ntikv-3/tikv.log:297342:[2022/10/04 15:51:15.929 +08:00] [WARN] [atomic_store.rs:49] [\"[rawkv-trace] atomic_store\"] [ts=TimeStamp(436435648755008534)] [key=7200000063613030FF3030303030333939FF3033353039300000FD] [value=02]\r\ntikv-3/tikv.log:297406:[2022/10/04 15:51:15.932 +08:00] [WARN] [raw_mvcc.rs:35] [\"rawkv-trace raw_mvcc\"] [value=02] [ts=TimeStamp(436435648755008534)] [key=7200000063613030FF3030303030333939FF3033353039300000FD]\r\ntikv-3/tikv.log:297408:[2022/10/04 15:51:15.932 +08:00] [WARN] [compare_and_swap.rs:104] [\"[rawkv-trace] cas succeed:false\"] [ts=TimeStamp(436435648755008588)] [key=7200000063613030FF3030303030333939FF3033353039300000FD] [value=3339393033353039315F30303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030] [old_value=]\r\ntikv-3/tikv.log:297419:[2022/10/04 15:51:15.932 +08:00] [WARN] [atomic_store.rs:49] [\"[rawkv-trace] atomic_store\"] [ts=TimeStamp(436435648755008606)] [key=7200000063613030FF3030303030333939FF3033353039300000FD] [value=3339393033353039305F3030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303000]\r\n...\r\n...\r\ntikv-1/tikv.log:106519:[2022/10/04 15:51:26.312 +08:00] [WARN] [raw_mvcc.rs:35] [\"rawkv-trace raw_mvcc\"] [value=3339393033353039305F3030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303000] [ts=TimeStamp(436435648755008606)] [key=7200000063613030FF3030303030333939FF3033353039300000FD]\r\ntikv-1/tikv.log:106521:[2022/10/04 15:51:26.312 +08:00] [WARN] [compare_and_swap.rs:72] [\"[rawkv-trace] cas succeed:true\"] [ts=TimeStamp(436435651475800143)] [key=7200000063613030FF3030303030333939FF3033353039300000FD] [value=3339393033353039315F30303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030] [old_value=3339393033353039305F30303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030]\r\ntikv-1/tikv.log:121539:[2022/10/04 15:51:26.779 +08:00] [WARN] [atomic_store.rs:49] [\"[rawkv-trace] atomic_store\"] [ts=TimeStamp(436435651592192934)] [key=7200000063613030FF3030303030333939FF3033353039300000FD] [value=3339393033353039305F3030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303000]\r\ntikv-1/tikv.log:121663:[2022/10/04 15:51:26.782 +08:00] [WARN] [raw_mvcc.rs:35] [\"rawkv-trace raw_mvcc\"] [value=3339393033353039305F3030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303000] [ts=TimeStamp(436435651592192934)] [key=7200000063613030FF3030303030333939FF3033353039300000FD]\r\n```\r\n\r\nWe can see that:\r\n* Line 1: the `cli.Delete`.\r\n* Line 2-3: the 1st try of `cli.CompareAndSwap`, not successful because the `cli.Put` is not performed yet.\r\n* Line 4: the `cli.Put`.\r\n* Line 5-6: (in another `tikv-server`) 2nd try of `cli.CompareAndSwap`, succeed. The `ts` is correctness (`436435651475800143 > 436435648755008606`).\r\n* Line 7: Another `cli.Put` ? This must be the retry of `cli.Put` in line 4, when we kill `tikv-3`. And it overwrite the result of line 5-6.\r\n* Line 8: the `cli.Get`. Which got the result of line 7.\r\n\r\nWhen client side gets a failure (e.g. a request timeout or a network unreachable), we have no idea whether the request also failed on server side. Then a retry would make the request be done again.\r\nRaw atomic commands should be used with caution.\r\n\r\nTo solve this issue, the test code is changed to:\r\n```golang\r\nTry(cli.Delete(ctx, key))\r\n\r\neg, ectx := errgroup.WithContext(ctx)\r\n\r\n// nil -> value0 -> value1\r\neg.Go(WithGinkgoRecover(func() {\r\n\tdoCAS(ectx, cli, key, nil, value0, false)\r\n}))\r\neg.Go(WithGinkgoRecover(func() {\r\n\tdoCAS(ectx, cli, key, value0, value1, true)\r\n}))\r\n\r\nTry(eg.Wait())\r\nresult := Try(cli.Get(ctx, key)).([]byte)\r\nExpect(result).Should(Equal(value1), \"key: %v, value0: %v, value1: %v\", string(key), string(value0), string(value1))\r\n```\r\n\r\n```golang\r\nfunc doCAS(ctx context.Context, cli client.Client, key, oldValue, newValue []byte, errorOnTimeout bool) {\r\n\tvar (\r\n\t\terr       error\r\n\t\tsucceed   bool\r\n\t\tretry     int\r\n\t\tprevValue []byte\r\n\t\telapsed   time.Duration\r\n\t)\r\n\tstart := time.Now()\r\n\tfor !succeed && !bytes.Equal(prevValue, newValue) && elapsed < CAS_RETRY_TIMEOUT {\r\n\t\tretry += 1\r\n\t\tif retry%CAS_RETRY_BACKOFF_BATCH == 0 {\r\n\t\t\ttime.Sleep(CAS_RETRY_BACKOFF_DURATION)\r\n\t\t}\r\n\r\n\t\tprevValue, succeed, err = cli.CompareAndSwap(ctx, key, oldValue, newValue)\r\n\t\tExpect(err).To(Succeed())\r\n\t\telapsed = time.Since(start)\r\n\t}\r\n\tif errorOnTimeout {\r\n\t\tExpect(elapsed < CAS_RETRY_TIMEOUT).To(BeTrue(), \"succeed: %v, key: %v, retry: %v, elapsed: %v, oldValue: %v, newValue: %v, prevValue: %v\",\r\n\t\t\tsucceed, string(key), retry, elapsed, string(oldValue), string(newValue), string(prevValue))\r\n\t}\r\n}\r\n```\r\n\r\nAlso note the first `cli.CompareAndSwap` would never succeed, if the successful result is missed and the value is changed to `value1` by the second `cli.CompareAndSwap` before a retry is invoked."
    },
    {
      "id": 1268124074,
      "user": "pingyu",
      "created_at": "2022-10-05T08:34:52Z",
      "body": "@haojinming @zeminzhou PTAL~"
    }
  ]
}