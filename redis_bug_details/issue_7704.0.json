{
  "issue_number": 7704.0,
  "title": "[BUG] `make test` fails: [exception]: Executing test client: error writing \"file70\": broken pipe. ",
  "body": "**Describe the bug**\r\n\r\n`make` runs OK and the server and CLI seem to run OK given a basic CRUD test .\r\nbut trying `make test` fails.\r\n\r\n**To reproduce**\r\n\r\n```\r\nwget http://download.redis.io/redis-stable.tar.gz\r\ntar xvzf redis-stable.tar.gz\r\ncd redis-stable\r\nmake test\r\n```\r\n\r\n**Expected behavior**\r\n\r\n`make test` should not fail\r\n\r\n**Additional information**\r\n\r\nGuessing this is a problem with either my system or the config (although I haven't added any of my own) as probably CI would not be OK with failing tests:\r\n\r\nBuilding on Ubuntu 18.04 on WSL 1 on Windows 10 (1809)\r\ngcc --version: 7.5.0\r\nmake --version: 4.1\r\npkg-config --version: 0.29.1\r\n\r\n\r\n\r\n<details>\r\n<summary>logged test output:</summary>\r\n\r\n```\r\ncd src && make test\r\nmake[1]: Entering directory '/home/toby/make-redis/redis-stable/src'\r\nCleanup: may take some time... OK\r\nStarting test server at port 11111\r\n[ready]: 2535\r\n\u001b[1;37;49mTesting unit/printver\u001b[0m\r\n[ready]: 2536\r\n\u001b[1;37;49mTesting unit/dump\u001b[0m\r\n[ready]: 2534\r\n\u001b[1;37;49mTesting unit/auth\u001b[0m\r\n[ready]: 2537\r\n\u001b[1;37;49mTesting unit/protocol\u001b[0m\r\n[ready]: 2538\r\n\u001b[1;37;49mTesting unit/keyspace\u001b[0m\r\n[ready]: 2539\r\n\u001b[1;37;49mTesting unit/scan\u001b[0m\r\n[ready]: 2540\r\n\u001b[1;37;49mTesting unit/type/string\u001b[0m\r\n[ready]: 2541\r\n\u001b[1;37;49mTesting unit/type/incr\u001b[0m\r\n[ready]: 2542\r\n\u001b[1;37;49mTesting unit/type/list\u001b[0m\r\n[ready]: 2544\r\n\u001b[1;37;49mTesting unit/type/list-2\u001b[0m\r\n[ready]: 2543\r\n\u001b[1;37;49mTesting unit/type/list-3\u001b[0m\r\n[ready]: 2545\r\n\u001b[1;37;49mTesting unit/type/set\u001b[0m\r\n[ready]: 2547\r\n\u001b[1;37;49mTesting unit/type/zset\u001b[0m\r\n[ready]: 2546\r\n\u001b[1;37;49mTesting unit/type/hash\u001b[0m\r\n[ready]: 2548\r\n\u001b[1;37;49mTesting unit/type/stream\u001b[0m\r\n[ready]: 2549\r\n\u001b[1;37;49mTesting unit/type/stream-cgroups\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS basic usage\r\n[\u001b[0;32;49mok\u001b[0m]: XADD can add entries into a stream that XRANGE can fetch\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS RANK (positive and negative rank) option\r\n[\u001b[0;32;49mok\u001b[0m]: AUTH fails if there is no password configured server side\r\n[\u001b[0;32;49mok\u001b[0m]: XADD IDs are incremental\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS COUNT option\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS COUNT + RANK option\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: XADD IDs are incremental when ms is the same as well\r\n[\u001b[0;32;49mok\u001b[0m]: Check encoding - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS no match\r\n[\u001b[0;32;49mok\u001b[0m]: Handle an empty query\r\n[\u001b[0;32;49mok\u001b[0m]: XADD IDs correctly report an error when overflowing\r\nTesting Redis version 6.0.6 (00000000)\r\n[\u001b[0;32;49mok\u001b[0m]: HSET/HLEN - Small hash creation\r\n[\u001b[0;32;49mok\u001b[0m]: Negative multibulk length\r\n[\u001b[0;32;49mok\u001b[0m]: Out of range multibulk length\r\n[\u001b[0;32;49mok\u001b[0m]: LPOS MAXLEN\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET basic ZADD and score update - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: DUMP / RESTORE are able to serialize / unserialize a simple key\r\n[\u001b[0;32;49mok\u001b[0m]: Is the small hash encoded with a ziplist?\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET element can't be set to NaN with ZADD - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Wrong multibulk payload header\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET element can't be set to NaN with ZINCRBY\r\n[\u001b[0;32;49mok\u001b[0m]: DEL against a single item\r\n[\u001b[0;32;49mok\u001b[0m]: Negative multibulk payload length\r\n[\u001b[0;32;49mok\u001b[0m]: SET and GET an item\r\n[\u001b[0;32;49mok\u001b[0m]: SADD, SCARD, SISMEMBER, SMEMBERS basics - regular set\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD with options syntax error with incomplete pair\r\n[\u001b[0;32;49mok\u001b[0m]: Out of range multibulk payload length\r\n[\u001b[0;32;49mok\u001b[0m]: Non-number multibulk payload length\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX option without key - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SET and GET an empty item\r\n[\u001b[0;32;49mok\u001b[0m]: Vararg DEL\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can set an arbitrary expire to the materialized key\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX existing key - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Multi bulk request not followed by bulk arguments\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can set an expire that overflows a 32 bit integer\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX returns the number of elements actually added\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can set an absolute expire\r\n[\u001b[0;32;49mok\u001b[0m]: Generic wrong number of args\r\n[\u001b[0;32;49mok\u001b[0m]: INCR against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: INCR against key created by incr itself\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE with ABSTTL in the past\r\n[\u001b[0;32;49mok\u001b[0m]: KEYS with pattern\r\n[\u001b[0;32;49mok\u001b[0m]: INCR against key originally set with SET\r\n[\u001b[0;32;49mok\u001b[0m]: INCR over 32bit value\r\n[\u001b[0;32;49mok\u001b[0m]: Explicit regression for a list bug\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBY over 32bit value with over 32bit increment\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can set LRU\r\n[\u001b[0;32;49mok\u001b[0m]: SADD, SCARD, SISMEMBER, SMEMBERS basics - intset\r\n[\u001b[0;32;49mok\u001b[0m]: INCR fails against key with spaces (left)\r\n[\u001b[0;32;49mok\u001b[0m]: KEYS to get all keys\r\n[\u001b[0;32;49mok\u001b[0m]: Unbalanced number of quotes\r\n[\u001b[0;32;49mok\u001b[0m]: INCR fails against key with spaces (right)\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can set LFU\r\n[\u001b[0;32;49mok\u001b[0m]: DBSIZE\r\n[\u001b[0;32;49mok\u001b[0m]: SADD against non set\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE returns an error of the key already exists\r\n[\u001b[0;32;49mok\u001b[0m]: INCR fails against key with spaces (both)\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX updates existing elements score\r\n[\u001b[0;32;49mok\u001b[0m]: Regression for quicklist #3343 bug\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX and NX are not compatible\r\n[\u001b[0;32;49mok\u001b[0m]: INCR fails against a key holding a list\r\n[\u001b[0;32;49mok\u001b[0m]: DECRBY over 32bit value with over 32bit increment, negative res\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD NX with non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: SADD a non-integer against an intset\r\n[\u001b[0;32;49mok\u001b[0m]: DEL all keys\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can overwrite an existing key with REPLACE\r\n[\u001b[0;32;49mok\u001b[0m]: RESTORE can detect a syntax error for unrecongized options\r\n[\u001b[0;32;49mok\u001b[0m]: SADD an integer larger than 64 bits\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD NX only add new elements without updating old ones\r\n[\u001b[0;32;49mok\u001b[0m]: DUMP of non existing key returns nil\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD INCR works like ZINCRBY\r\n[\u001b[0;32;49mok\u001b[0m]: INCR uses shared objects in the 0-9999 range\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD INCR works with a single score-elemenet pair\r\n[\u001b[0;32;49mok\u001b[0m]: INCR can modify objects in-place\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD CH option changes return value to all changed elements\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT against key originally set with SET\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT over 32bit value\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT over 32bit value with over 32bit increment\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY calls leading to NaN result in error\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT fails against key with spaces (left)\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT fails against key with spaces (right)\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version base case\r\n[\u001b[0;32;49mok\u001b[0m]: R/LPOP against empty list\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT fails against key with spaces (both)\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Return value is the number of actually added items\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT fails against a key holding a list\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT does not allow NaN or Infinity\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version does not add nothing on single parsing err\r\n[\u001b[0;32;49mok\u001b[0m]: Variadic RPUSH/LPUSH\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT decrement\r\n[\u001b[0;32;49mok\u001b[0m]: DEL a list\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version will raise error on missing arg\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY does not work variadic even if shares ZADD implementation\r\n[\u001b[0;32;49mok\u001b[0m]: string to double with null terminator\r\n[\u001b[0;32;49mok\u001b[0m]: ZCARD basics - ziplist\r\n[\u001b[0;31;49merr\u001b[0m]: No negative zero in tests/unit/type/incr.tcl\r\nExpected '0' to equal or match '0.00000000000000001'\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM removes key after last element is removed\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN basic\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: single existing list - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM variadic version\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM variadic version -- remove elements after key deletion\r\n[\u001b[0;32;49mok\u001b[0m]: XGROUP CREATE: creation and duplicate group name detection\r\n[\u001b[0;32;49mok\u001b[0m]: XGROUP CREATE: automatic stream creation fails without MKSTREAM\r\n[\u001b[0;32;49mok\u001b[0m]: XGROUP CREATE: automatic stream creation works with MKSTREAM\r\n[\u001b[0;32;49mok\u001b[0m]: XREADGROUP will return only new elements\r\n[\u001b[0;32;49mok\u001b[0m]: XREADGROUP can read the history of the elements we own\r\n[\u001b[0;32;49mok\u001b[0m]: XPENDING is able to return pending items\r\n[\u001b[0;32;49mok\u001b[0m]: XPENDING can return single consumer items\r\n[\u001b[0;32;49mok\u001b[0m]: XACK is able to remove items from the client/group PEL\r\n[\u001b[0;32;49mok\u001b[0m]: XACK can't remove the same item multiple times\r\n[\u001b[0;32;49mok\u001b[0m]: XACK is able to accept multiple arguments\r\n[\u001b[0;32;49mok\u001b[0m]: XACK should fail if got at least one invalid ID\r\n[\u001b[0;32;49mok\u001b[0m]: PEL NACK reassignment after XGROUP SETID event\r\n[1/56 \u001b[0;33;49mdone\u001b[0m]: unit/printver (2 seconds)\r\n\u001b[1;37;49mTesting unit/sort\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: multiple existing lists - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: XREADGROUP will not report data on empty history. Bug #5577\r\n[\u001b[0;32;49mok\u001b[0m]: XREADGROUP history reporting of deleted entries. Bug #5570\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGE basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: second list has an entry - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: Very big payload in GET/SET\r\n[\u001b[0;32;49mok\u001b[0m]: Blocking XREADGROUP will not reply with an empty array\r\n[\u001b[0;32;49mok\u001b[0m]: XGROUP DESTROY should unblock XREADGROUP with -NOGROUP\r\n[\u001b[0;32;49mok\u001b[0m]: ZREVRANGE basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME can unblock XREADGROUP with data\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME can unblock XREADGROUP with -NOGROUP\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: single existing list - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANK/ZREVRANK basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Protocol desync regression test #1\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANK - after deletion - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY - can create a new sorted set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY - increment and decrement - ziplist\r\n[2/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/incr (2 seconds)\r\n\u001b[1;37;49mTesting unit/expire\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY return value\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: multiple existing lists - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN COUNT\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, BRPOP: second list has an entry - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, LPUSH + DEL should not awake blocked client\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP, LPUSH + DEL + SET should not awake blocked client\r\n[\u001b[0;32;49mok\u001b[0m]: DEL against expired key\r\n[\u001b[0;32;49mok\u001b[0m]: EXISTS\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP with same key multiple times should work (issue #801)\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN MATCH\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with WITHSCORES\r\n[\u001b[0;32;49mok\u001b[0m]: Zero length value in key. SET/GET/EXISTS\r\n[\u001b[0;32;49mok\u001b[0m]: Commands pipelining\r\n[\u001b[0;32;49mok\u001b[0m]: Non existing command\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI/EXEC is isolated from the point of view of BLPOP\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME basic usage\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME source key should no longer exist\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP with variadic LPUSH\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME against already existing key\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with LIMIT\r\n[\u001b[0;32;49mok\u001b[0m]: AUTH fails when a wrong password is given\r\n[\u001b[0;32;49mok\u001b[0m]: RENAMENX basic usage\r\n[\u001b[0;32;49mok\u001b[0m]: Arbitrary command gives an error when AUTH is required\r\n[\u001b[0;32;49mok\u001b[0m]: RENAMENX against already existing key\r\n[\u001b[0;32;49mok\u001b[0m]: AUTH succeeds when the right password is given\r\n[\u001b[0;32;49mok\u001b[0m]: Once AUTH succeeded we can actually send commands to the server\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES\r\n[\u001b[0;32;49mok\u001b[0m]: RENAMENX against already existing key (2)\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME against non existing source key\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME where source and dest key are the same (existing)\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with non-value min or max\r\n[\u001b[0;32;49mok\u001b[0m]: RENAMENX where source and dest key are the same (existing)\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME where source and dest key are the same (non existing)\r\n[\u001b[0;32;49mok\u001b[0m]: Old Ziplist: SORT BY key\r\n[\u001b[0;32;49mok\u001b[0m]: Old Ziplist: SORT BY key with limit\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE is caching connections\r\n[\u001b[0;32;49mok\u001b[0m]: Old Ziplist: SORT BY hash field\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME with volatile key, should move the TTL as well\r\n[\u001b[0;32;49mok\u001b[0m]: RENAME with volatile key, should not inherit TTL of target key\r\n[\u001b[0;32;49mok\u001b[0m]: DEL all keys again (DB 0)\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE - set timeouts multiple times\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE - It should be still possible to read 'x'\r\n[\u001b[0;32;49mok\u001b[0m]: DEL all keys again (DB 1)\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics\r\n[\u001b[0;32;49mok\u001b[0m]: MOVE basic usage\r\n[\u001b[0;32;49mok\u001b[0m]: MOVE against key existing in the target DB\r\n[\u001b[0;32;49mok\u001b[0m]: MOVE against non-integer DB (#1428)\r\n[\u001b[0;32;49mok\u001b[0m]: ZLEXCOUNT advanced\r\n[\u001b[0;32;49mok\u001b[0m]: XCLAIM can claim PEL items from another consumer\r\n[\u001b[0;32;49mok\u001b[0m]: MOVE can move key expire metadata as well\r\n[\u001b[0;32;49mok\u001b[0m]: Protocol desync regression test #2\r\n[\u001b[0;32;49mok\u001b[0m]: MOVE does not create an expire if it does not exist\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSLEX with LIMIT\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYLEX with invalid lex range specifiers\r\n[\u001b[0;32;49mok\u001b[0m]: SET/GET keys in different DBs\r\n[\u001b[0;32;49mok\u001b[0m]: RANDOMKEY\r\n[\u001b[0;32;49mok\u001b[0m]: RANDOMKEY against empty DB\r\n[\u001b[0;32;49mok\u001b[0m]: RANDOMKEY regression 1\r\n[\u001b[0;32;49mok\u001b[0m]: KEYS * two times with long key, Github issue #1208\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYSCORE basics\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYSCORE with non-value min or max\r\n[3/56 \u001b[0;33;49mdone\u001b[0m]: unit/auth (3 seconds)\r\n\u001b[1;37;49mTesting unit/other\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN TYPE\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYRANK basics\r\n[\u001b[0;32;49mok\u001b[0m]: SSCAN with encoding intset\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with empty set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: XCLAIM without JUSTID increments delivery count\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SSCAN with encoding hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with weights - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: HSCAN with encoding ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with a regular set and weights - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with AGGREGATE MIN - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with AGGREGATE MAX - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with weights - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: HSET/HLEN - Big hash creation\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with a regular set and weights - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: XINFO FULL output\r\n[\u001b[0;32;49mok\u001b[0m]: Is the big hash encoded with an hash table?\r\n[\u001b[0;32;49mok\u001b[0m]: HGET against the small hash\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with AGGREGATE MIN - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with AGGREGATE MAX - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with +inf/-inf scores - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with NaN weights ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH with zero timeout should block indefinitely\r\n[\u001b[0;32;49mok\u001b[0m]: SADD overflows the maximum allowed integers in an intset\r\n[\u001b[0;32;49mok\u001b[0m]: Variadic SADD\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with +inf/-inf scores - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with NaN weights ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Protocol desync regression test #3\r\n[\u001b[0;32;49mok\u001b[0m]: Basic ZPOP with a single key - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZPOP with count - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP with a single existing sorted set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SAVE - make sure there are all the types as values\r\n[\u001b[0;32;49mok\u001b[0m]: HSCAN with encoding hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCAN with encoding ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP with multiple existing sorted sets - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP second sorted set has members - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Check encoding - skiplist\r\n[4/56 \u001b[0;33;49mdone\u001b[0m]: unit/keyspace (4 seconds)\r\n\u001b[1;37;49mTesting unit/multi\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET basic ZADD and score update - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET element can't be set to NaN with ZADD - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET element can't be set to NaN with ZINCRBY\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD with options syntax error with incomplete pair\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX option without key - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX existing key - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX returns the number of elements actually added\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX updates existing elements score\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD XX and NX are not compatible\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD NX with non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD NX only add new elements without updating old ones\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD INCR works like ZINCRBY\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD INCR works with a single score-elemenet pair\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD CH option changes return value to all changed elements\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY calls leading to NaN result in error\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version base case\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Return value is the number of actually added items\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version does not add nothing on single parsing err\r\n[\u001b[0;32;49mok\u001b[0m]: ZADD - Variadic version will raise error on missing arg\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY does not work variadic even if shares ZADD implementation\r\n[\u001b[0;32;49mok\u001b[0m]: ZCARD basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM removes key after last element is removed\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM variadic version\r\n[\u001b[0;32;49mok\u001b[0m]: ZREM variadic version -- remove elements after key deletion\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCAN with encoding skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGE basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZREVRANGE basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANK/ZREVRANK basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANK - after deletion - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: MUTLI / EXEC basics\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY - can create a new sorted set - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY - increment and decrement - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: DISCARD\r\n[\u001b[0;32;49mok\u001b[0m]: ZINCRBY return value\r\n[\u001b[0;32;49mok\u001b[0m]: Nested MULTI are not allowed\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI where commands alter argc/argv\r\n[\u001b[0;32;49mok\u001b[0m]: WATCH inside MULTI is not allowed\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC fails if there are errors while queueing commands #1\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC fails if there are errors while queueing commands #2\r\n[\u001b[0;32;49mok\u001b[0m]: If EXEC aborts, the client MULTI state is cleared\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC works on WATCHed key not modified\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC fail on WATCHed key modified (1 key of 1 watched)\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with WITHSCORES\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC fail on WATCHed key modified (1 key of 5 watched)\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with LIMIT\r\n[\u001b[0;32;49mok\u001b[0m]: After successful EXEC key is no longer watched\r\n[\u001b[0;32;49mok\u001b[0m]: HGET against the big hash\r\n[\u001b[0;32;49mok\u001b[0m]: HGET against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE with non-value min or max\r\n[\u001b[0;32;49mok\u001b[0m]: HSET in update and insert mode\r\n[\u001b[0;32;49mok\u001b[0m]: HSETNX target key missing - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: After failed EXEC key is no longer watched\r\n[\u001b[0;32;49mok\u001b[0m]: HSETNX target key exists - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN guarantees check under write load\r\n[\u001b[0;32;49mok\u001b[0m]: HSETNX target key missing - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH with a client BLPOPing the target list\r\n[\u001b[0;32;49mok\u001b[0m]: HSETNX target key exists - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: It is possible to UNWATCH\r\n[\u001b[0;32;49mok\u001b[0m]: HMSET wrong number of args\r\n[\u001b[0;32;49mok\u001b[0m]: UNWATCH when there is nothing watched works as expected\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH with wrong source type\r\n[\u001b[0;32;49mok\u001b[0m]: SSCAN with integer encoded object (issue #1345)\r\n[\u001b[0;32;49mok\u001b[0m]: HMSET - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: HMSET - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: SSCAN with PATTERN\r\n[\u001b[0;32;49mok\u001b[0m]: HMGET against non existing key and fields\r\n[\u001b[0;32;49mok\u001b[0m]: HMGET against wrong type\r\n[\u001b[0;32;49mok\u001b[0m]: HSCAN with PATTERN\r\n[\u001b[0;32;49mok\u001b[0m]: HMGET - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: HMGET - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCAN with PATTERN\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHALL is able to touch the watched keys\r\n[\u001b[0;32;49mok\u001b[0m]: HKEYS - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics\r\n[\u001b[0;32;49mok\u001b[0m]: HKEYS - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: HVALS - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHALL does not touch non affected keys\r\n[\u001b[0;32;49mok\u001b[0m]: HVALS - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHDB is able to touch the watched keys\r\n[\u001b[0;32;49mok\u001b[0m]: HGETALL - small hash\r\n[\u001b[0;32;49mok\u001b[0m]: HGETALL - big hash\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHDB does not touch non affected keys\r\n[\u001b[0;32;49mok\u001b[0m]: HDEL and return value\r\n[\u001b[0;32;49mok\u001b[0m]: ZLEXCOUNT advanced\r\n[\u001b[0;32;49mok\u001b[0m]: HDEL - more than a single value\r\n[\u001b[0;32;49mok\u001b[0m]: HDEL - hash becomes empty before deleting all specified fields\r\n[\u001b[0;32;49mok\u001b[0m]: HEXISTS\r\n[\u001b[0;32;49mok\u001b[0m]: WATCH is able to remember the DB a key belongs to\r\n[\u001b[0;32;49mok\u001b[0m]: Is a ziplist encoded Hash promoted on big payload?\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY against non existing database key\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY against non existing hash key\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY against hash key created by hincrby itself\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY against hash key originally set with HSET\r\n[\u001b[0;32;49mok\u001b[0m]: WATCH will consider touched keys target of EXPIRE\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSLEX with LIMIT\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY over 32bit value\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY over 32bit value with over 32bit increment\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY fails against hash value with spaces (left)\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYLEX with invalid lex range specifiers\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY fails against hash value with spaces (right)\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBY can detect overflows\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT against non existing database key\r\n[\u001b[0;32;49mok\u001b[0m]: Consumer group last ID propagation to slave (NOACK=0)\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT against non existing hash key\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT against hash key created by hincrby itself\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT against hash key originally set with HSET\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT over 32bit value\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT over 32bit value with over 32bit increment\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT fails against hash value with spaces (left)\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT fails against hash value with spaces (right)\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE - After 2.1 seconds the key should no longer be here\r\n[\u001b[0;32;49mok\u001b[0m]: HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle\r\n[\u001b[0;32;49mok\u001b[0m]: HSTRLEN against the small hash\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE - write on expire should work\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIREAT - Check for EXPIRE alike behavior\r\n[\u001b[0;32;49mok\u001b[0m]: SETEX - Set + Expire combo operation. Check for TTL\r\n[\u001b[0;32;49mok\u001b[0m]: Regression for a crash with blocking ops and pipelining\r\n[\u001b[0;32;49mok\u001b[0m]: SETEX - Check value\r\n[\u001b[0;32;49mok\u001b[0m]: SETEX - Overwrite old key\r\n[\u001b[0;32;49mok\u001b[0m]: XADD with MAXLEN option\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYSCORE basics\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYSCORE with non-value min or max\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYRANK basics\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with empty set - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with weights - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with a regular set and weights - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with AGGREGATE MIN - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with AGGREGATE MAX - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE basics - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with weights - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with a regular set and weights - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with AGGREGATE MIN - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with AGGREGATE MAX - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with +inf/-inf scores - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE with NaN weights skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with +inf/-inf scores - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE with NaN weights skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: Basic ZPOP with a single key - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZPOP with count - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP with a single existing sorted set - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP with multiple existing sorted sets - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOP second sorted set has members - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE regression with two sets, intset+hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE regression, should not create NaN in scores\r\n[5/56 \u001b[0;33;49mdone\u001b[0m]: unit/protocol (5 seconds)\r\n\u001b[1;37;49mTesting unit/quit\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH with wrong destination type\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH maintains order of elements after failure\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH with multiple blocked clients\r\n[\u001b[0;32;49mok\u001b[0m]: ZUNIONSTORE result is sorted\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET commands don't accept the empty strings as valid score\r\n[\u001b[0;32;49mok\u001b[0m]: Linked BRPOPLPUSH\r\n[\u001b[0;32;49mok\u001b[0m]: Circular BRPOPLPUSH\r\n[\u001b[0;32;49mok\u001b[0m]: Self-referential BRPOPLPUSH\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH inside a transaction\r\n[\u001b[0;32;49mok\u001b[0m]: PUSH resulting from BRPOPLPUSH affect WATCH\r\n[\u001b[0;32;49mok\u001b[0m]: WATCH will not consider touched expired keys\r\n[\u001b[0;32;49mok\u001b[0m]: Consumer group last ID propagation to slave (NOACK=1)\r\n[\u001b[0;31;49merr\u001b[0m]: BRPOPLPUSH does not affect WATCH while still blocked in tests/unit/type/list.tcl\r\nExpected 'somevalue' to equal or match ''\r\n[\u001b[0;32;49mok\u001b[0m]: DISCARD should clear the WATCH dirty flag on the client\r\n[\u001b[0;32;49mok\u001b[0m]: DISCARD should UNWATCH all the keys\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCAN scores: regression test for issue #2175\r\n[\u001b[0;32;49mok\u001b[0m]: SETEX - Wait for the key to expire\r\n[\u001b[0;32;49mok\u001b[0m]: SETEX - Wrong time parameter\r\n[\u001b[0;32;49mok\u001b[0m]: PERSIST can undo an EXPIRE\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI / EXEC is propagated correctly (single write command)\r\n[\u001b[0;32;49mok\u001b[0m]: PERSIST returns 0 against non existing or non volatile keys\r\n[\u001b[0;32;49mok\u001b[0m]: HSTRLEN against the big hash\r\n[\u001b[0;32;49mok\u001b[0m]: HSTRLEN against non existing field\r\n[\u001b[0;32;49mok\u001b[0m]: HSTRLEN corner cases\r\n[\u001b[0;32;49mok\u001b[0m]: Hash ziplist regression test for large keys\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI / EXEC is propagated correctly (empty transaction)\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI / EXEC is propagated correctly (read-only commands)\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI / EXEC is propagated correctly (write command, no effect)\r\n[\u001b[0;32;49mok\u001b[0m]: DISCARD should not fail during OOM\r\n[\u001b[0;32;49mok\u001b[0m]: Hash fuzzing #1 - 10 fields\r\n[\u001b[0;32;49mok\u001b[0m]: QUIT returns OK\r\n[\u001b[0;32;49mok\u001b[0m]: Pipelined commands after QUIT must not be executed\r\n[\u001b[0;32;49mok\u001b[0m]: Pipelined commands after QUIT that exceed read buffer size\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCORE - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: Hash fuzzing #2 - 10 fields\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI and script timeout\r\n[6/56 \u001b[0;33;49mdone\u001b[0m]: unit/quit (2 seconds)\r\n\u001b[1;37;49mTesting unit/aofrw\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCORE after a DEBUG RELOAD - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: EXEC and script timeout\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI-EXEC body and script timeout\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH timeout\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP when new key is moved into place\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP when result key is created by SORT..STORE\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: with single empty list argument\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: with negative timeout\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: with non-integer timeout\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE pricision is now the millisecond\r\n[\u001b[0;32;49mok\u001b[0m]: Empty stream with no lastid can be rewrite into AOF correctly\r\n[\u001b[0;32;49mok\u001b[0m]: just EXEC and script timeout\r\n[\u001b[0;32;49mok\u001b[0m]: exec with write commands and state change\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET sorting stresser - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: exec with read commands and stale replica state change\r\n[\u001b[0;32;49mok\u001b[0m]: Set encoding after DEBUG RELOAD\r\n[\u001b[0;32;49mok\u001b[0m]: SREM basics - regular set\r\n[\u001b[0;32;49mok\u001b[0m]: SREM basics - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SREM with multiple arguments\r\n[\u001b[0;32;49mok\u001b[0m]: SREM variadic version with more args needed to destroy the key\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: with zero timeout should block indefinitely\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: second argument is not a list\r\n[7/56 \u001b[0;33;49mdone\u001b[0m]: unit/multi (5 seconds)\r\n\u001b[1;37;49mTesting unit/acl\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: timeout\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP: arguments are empty\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: with single empty list argument\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: with negative timeout\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: with non-integer timeout\r\n[\u001b[0;31;49merr\u001b[0m]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires in tests/unit/expire.tcl\r\nExpected 'somevalue {}' to equal or match '{} {}'\r\n[\u001b[0;32;49mok\u001b[0m]: TTL returns time to live in seconds\r\n[8/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/stream-cgroups (11 seconds)\r\n\u001b[1;37;49mTesting unit/latency-monitor\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: PTTL returns time to live in milliseconds\r\n[\u001b[0;32;49mok\u001b[0m]: TTL / PTTL return -1 if key has no expire\r\n[\u001b[0;32;49mok\u001b[0m]: TTL / PTTL return -2 if key does not exit\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: with zero timeout should block indefinitely\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: second argument is not a list\r\n[\u001b[0;32;49mok\u001b[0m]: Very big payload random access\r\n[\u001b[0;32;49mok\u001b[0m]: Connections start with the default user\r\n[\u001b[0;32;49mok\u001b[0m]: It is possible to create new users\r\n[\u001b[0;32;49mok\u001b[0m]: New users start disabled\r\n[\u001b[0;32;49mok\u001b[0m]: Enabling the user allows the login\r\n[\u001b[0;32;49mok\u001b[0m]: Redis should actively expire keys incrementally\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: timeout\r\n[\u001b[0;32;49mok\u001b[0m]: Only the set of correct passwords work\r\n[\u001b[0;32;49mok\u001b[0m]: It is possible to remove passwords from the set of valid ones\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOP: arguments are empty\r\n[\u001b[0;32;49mok\u001b[0m]: Test password hashes can be added\r\n[\u001b[0;32;49mok\u001b[0m]: Test password hashes validate input\r\n[\u001b[0;32;49mok\u001b[0m]: ACL GETUSER returns the password hash instead of the actual password\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP inside a transaction\r\n[\u001b[0;32;49mok\u001b[0m]: Test hashed passwords removal\r\n[\u001b[0;32;49mok\u001b[0m]: By default users are not able to access any command\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSHX, RPUSHX - generic\r\n[\u001b[0;32;49mok\u001b[0m]: By default users are not able to access any key\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSHX, RPUSHX - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: It's possible to allow the access of a subset of keys\r\n[\u001b[0;32;49mok\u001b[0m]: Users can be configured to authenticate with any password\r\n[\u001b[0;32;49mok\u001b[0m]: ACLs can exclude single commands\r\n[\u001b[0;32;49mok\u001b[0m]: Redis should lazy expire keys\r\n[\u001b[0;32;49mok\u001b[0m]: LINSERT - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: ACLs can include or exclude whole classes of commands\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSHX, RPUSHX - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: ACLs can include single subcommands\r\n[\u001b[0;32;49mok\u001b[0m]: ACL GETUSER is able to translate back command permissions\r\n[\u001b[0;32;49mok\u001b[0m]: ACL #5998 regression: memory leaks adding / removing subcommands\r\n[\u001b[0;32;49mok\u001b[0m]: LINSERT - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LINSERT raise error on bad syntax\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG shows failed command executions at toplevel\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE should not resurrect keys (issue #1026)\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG is able to test similar events\r\n[\u001b[0;32;49mok\u001b[0m]: 5 keys in, 5 keys out\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG is able to log keys access violations and key name\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRE with empty string as TTL should report an error\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG RESET is able to flush the entries in the log\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG can distinguish the transaction context (1)\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG can distinguish the transaction context (2)\r\n[\u001b[0;32;49mok\u001b[0m]: ACL can log errors in the context of Lua scripting\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG can accept a numerical argument to show less entries\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG can log failed auth attempts\r\n[\u001b[0;32;49mok\u001b[0m]: ACL LOG entries are limited to a maximum amount\r\n[\u001b[0;32;49mok\u001b[0m]: When default user is off, new connections are not authenticated\r\n[\u001b[0;32;49mok\u001b[0m]: ACL HELP should not have unexpected options\r\n[\u001b[0;32;49mok\u001b[0m]: Test latency events logging\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY HISTORY output is ok\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY LATEST output is ok\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY HISTORY / RESET with wrong event name is fine\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY DOCTOR produces some output\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE cached connections are released after some time\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY RESET is able to reset events\r\n[9/56 \u001b[0;33;49mdone\u001b[0m]: unit/acl (10 seconds)\r\n\u001b[1;37;49mTesting integration/block-repl\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: FUZZ stresser with data model binary\r\n[\u001b[0;32;49mok\u001b[0m]: Generated sets must be encoded as hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER with two sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with two sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE is able to migrate a key between two instances\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SUNION with two sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SUNIONSTORE with two sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER against three sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with three sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SET - use EX/PX option, TTL should not be reseted after loadaof\r\n[\u001b[0;32;49mok\u001b[0m]: SUNION with non existing keys - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SET command will remove expire\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with two sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with three sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SET - use KEEPTTL option, TTL should not be removed\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFFSTORE with three sets - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE is able to copy a key between two instances\r\n[\u001b[0;32;49mok\u001b[0m]: SET - use KEEPTTL option, TTL should not be removed after loadaof\r\n[\u001b[0;32;49mok\u001b[0m]: Old Linked list: SORT BY key\r\n[\u001b[0;32;49mok\u001b[0m]: Old Linked list: SORT BY key with limit\r\n[\u001b[0;32;49mok\u001b[0m]: Old Linked list: SORT BY hash field\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX consistency test - quicklist\r\n[10/56 \u001b[0;33;49mdone\u001b[0m]: unit/expire (21 seconds)\r\n\u001b[1;37;49mTesting integration/replication\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE will not overwrite existing keys, unless REPLACE is used\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite during write load: RDB preamble=yes\r\n[\u001b[0;32;49mok\u001b[0m]: Generated sets must be encoded as intset\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER with two sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with two sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SUNION with two sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SUNIONSTORE with two sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER against three sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE with three sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SUNION with non existing keys - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with two sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with three sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFFSTORE with three sets - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with first set empty\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF with same set two times\r\n[\u001b[0;32;49mok\u001b[0m]: Slave enters handshake\r\n[\u001b[0;32;49mok\u001b[0m]: MIGRATE propagates TTL correctly\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX random access - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY of expire events are correctly collected\r\n[\u001b[0;32;49mok\u001b[0m]: LATENCY HELP should not have unexpected options\r\n[11/56 \u001b[0;33;49mdone\u001b[0m]: unit/latency-monitor (24 seconds)\r\n\u001b[1;37;49mTesting integration/replication-2\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: FUZZ stresser with data model alpha\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: If min-slaves-to-write is honored, write is accepted\r\n[\u001b[0;32;49mok\u001b[0m]: No write if min-slaves-to-write is < attached slaves\r\n[\u001b[0;32;49mok\u001b[0m]: If min-slaves-to-write is honored, write is accepted (again)\r\n[\u001b[0;32;49mok\u001b[0m]: Slave is able to detect timeout during handshake\r\n[\u001b[0;32;49mok\u001b[0m]: Hash fuzzing #1 - 512 fields\r\n[\u001b[0;32;49mok\u001b[0m]: Set instance A as slave of B\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX consistency test - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: Stress tester for #3343-alike bugs\r\n[\u001b[0;32;49mok\u001b[0m]: INCRBYFLOAT replication, should not remove expire\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH replication, when blocking against empty list\r\n[\u001b[0;32;49mok\u001b[0m]: FUZZ stresser with data model compr\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX random access - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: BRPOPLPUSH replication, list exists\r\n[\u001b[0;32;49mok\u001b[0m]: BLPOP followed by role change, issue #2473\r\n[\u001b[0;32;49mok\u001b[0m]: No write if min-slaves-max-lag is > of the slave lag\r\n[\u001b[0;32;49mok\u001b[0m]: BGSAVE\r\n[\u001b[0;32;49mok\u001b[0m]: SELECT an out of range DB\r\n[\u001b[0;32;49mok\u001b[0m]: min-slaves-to-write is ignored by slaves\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRES after a reload (snapshot + append only file rewrite)\r\n[\u001b[0;32;49mok\u001b[0m]: Second server should have role master at first\r\n[\u001b[0;32;49mok\u001b[0m]: SLAVEOF should start with link status \"down\"\r\n[\u001b[0;32;49mok\u001b[0m]: The role should immediately be changed to \"replica\"\r\n[\u001b[0;32;49mok\u001b[0m]: Sync should have transferred keys from master\r\n[\u001b[0;32;49mok\u001b[0m]: The link status should be up\r\n[\u001b[0;32;49mok\u001b[0m]: SET on the master should immediately propagate\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHALL should replicate\r\n[\u001b[0;32;49mok\u001b[0m]: ROLE in master reports master with a slave\r\n[\u001b[0;32;49mok\u001b[0m]: ROLE in slave reports slave in connected state\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite during write load: RDB preamble=no\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication with blocking lists and sorted sets operations\r\n[\u001b[0;32;49mok\u001b[0m]: EXPIRES after AOF reload (without rewrite)\r\n[12/56 \u001b[0;33;49mdone\u001b[0m]: integration/block-repl (30 seconds)\r\n\u001b[1;37;49mTesting integration/replication-3\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: LLEN against non-list value error\r\n[\u001b[0;32;49mok\u001b[0m]: LLEN against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX against non-list value error\r\n[\u001b[0;32;49mok\u001b[0m]: LINDEX against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: LPUSH against non-list value error\r\n[\u001b[0;32;49mok\u001b[0m]: RPUSH against non-list value error\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH base case - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with the same list as src and dst - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with linkedlist source and existing target linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with linkedlist source and existing target ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: PIPELINING stresser (also a regression for the old epoll bug)\r\n[\u001b[0;32;49mok\u001b[0m]: APPEND basics\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH base case - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: APPEND basics, integer encoded values\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with the same list as src and dst - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with ziplist source and existing target linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH with ziplist source and existing target ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH against non list src key\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH against non list dst key\r\n[\u001b[0;32;49mok\u001b[0m]: RPOPLPUSH against non existing src key\r\n[\u001b[0;32;49mok\u001b[0m]: Basic LPOP/RPOP - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: Basic LPOP/RPOP - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LPOP/RPOP against non list value\r\n[\u001b[0;32;49mok\u001b[0m]: Turning off AOF kills the background writing child if any\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: Mass RPOP/LPOP - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: Hash fuzzing #2 - 512 fields\r\n[\u001b[0;32;49mok\u001b[0m]: ziplist implementation: value encoding and backlink\r\n[\u001b[0;32;49mok\u001b[0m]: Mass RPOP/LPOP - quicklist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE basics - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of list with quicklist encoding, string data\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE inverted indexes - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE out of range indexes including the full list - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE out of range negative end index - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE inverted indexes - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE out of range indexes including the full list - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE out of range negative end index - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LRANGE against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: LTRIM basics - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LTRIM out of range negative end index - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LTRIM basics - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LTRIM out of range negative end index - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LSET - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LSET out of range index - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LSET - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LSET out of range index - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LSET against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: LSET against non list value\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove all the occurrences - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove the first occurrence - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove non existing element - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM starting from tail with negative count - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM starting from tail with negative count (2) - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM deleting objects that may be int encoded - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove all the occurrences - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove the first occurrence - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM remove non existing element - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM starting from tail with negative count - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM starting from tail with negative count (2) - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LREM deleting objects that may be int encoded - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: XADD mass insertion and XLEN\r\n[\u001b[0;32;49mok\u001b[0m]: XADD with ID 0-0\r\n[\u001b[0;32;49mok\u001b[0m]: XRANGE COUNT works as expected\r\n[\u001b[0;32;49mok\u001b[0m]: XREVRANGE COUNT works as expected\r\n[\u001b[0;32;49mok\u001b[0m]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds\r\n[13/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/list (59 seconds)\r\n\u001b[1;37;49mTesting integration/replication-4\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: XRANGE can be used to iterate the whole stream\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of list with quicklist encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: APPEND fuzzing\r\n[\u001b[0;32;49mok\u001b[0m]: FLUSHDB\r\n[\u001b[0;32;49mok\u001b[0m]: Perform a final SAVE to leave a clean DB on disk\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of set with intset encoding, string data\r\n[14/56 \u001b[0;33;49mdone\u001b[0m]: unit/other (60 seconds)\r\n\u001b[1;37;49mTesting integration/replication-psync\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: XREVRANGE returns the reverse of XRANGE\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD with non empty stream\r\n[\u001b[0;32;49mok\u001b[0m]: Non blocking XREAD with empty streams\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD with non empty second stream\r\n[\u001b[0;32;49mok\u001b[0m]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=disabled\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of set with hashtable encoding, string data\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: no reconnection, just sync (diskless: no, disabled, reconnect: 0)\r\n[\u001b[0;32;49mok\u001b[0m]: Stress test the hash ziplist -> hashtable encoding conversion\r\n[\u001b[0;31;49merr\u001b[0m]: Test HINCRBYFLOAT for correct float representation (issue #2846) in tests/unit/type/hash.tcl\r\nExpected [r hincrbyfloat myhash float 1.23] eq {1.23} (context: type eval line 3 cmd {assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}} proc ::test)\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication with parallel clients writing in differnet DBs\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of set with intset encoding, int data\r\n[15/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/hash (67 seconds)\r\n\u001b[1;37;49mTesting integration/aof\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Unfinished MULTI: Server should start if load-truncated is yes\r\n[\u001b[0;32;49mok\u001b[0m]: Short read: Server should start if load-truncated is yes\r\n[\u001b[0;32;49mok\u001b[0m]: Truncated AOF loaded: we expect foo to be equal to 5\r\n[\u001b[0;32;49mok\u001b[0m]: Append a new command after loading an incomplete AOF\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: With min-slaves-to-write (1,3): master should be writable\r\n[\u001b[0;32;49mok\u001b[0m]: With min-slaves-to-write (2,3): master should not be writable\r\n[\u001b[0;32;49mok\u001b[0m]: Short read + command: Server should start\r\n[\u001b[0;32;49mok\u001b[0m]: Truncated AOF loaded: we expect foo to be equal to 6 now\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: Bad format: Server should have logged an error\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of set with hashtable encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: Unfinished MULTI: Server should have logged an error\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of hash with ziplist encoding, string data\r\n[\u001b[0;32;49mok\u001b[0m]: Short read: Server should have logged an error\r\n[\u001b[0;32;49mok\u001b[0m]: With min-slaves-to-write: master not writable with lagged slave\r\n[\u001b[0;32;49mok\u001b[0m]: Short read: Utility should confirm the AOF is not valid\r\n[\u001b[0;32;49mok\u001b[0m]: Short read: Utility should be able to fix the AOF\r\n[\u001b[0;32;49mok\u001b[0m]: Fixed AOF: Server should have been started\r\n[\u001b[0;32;49mok\u001b[0m]: Fixed AOF: Keyspace should contain values that were parseable\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+SPOP: Server should have been started\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+SPOP: Set should have 1 member\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: ok psync (diskless: no, disabled, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+SPOP: Server should have been started\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+SPOP: Set should have 1 member\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of hash with hashtable encoding, string data\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+EXPIRE: Server should have been started\r\n[\u001b[0;32;49mok\u001b[0m]: AOF+EXPIRE: List should be empty\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of hash with ziplist encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: Redis should not try to convert DEL into EXPIREAT for EXPIRE -1\r\n[\u001b[0;31;49merr\u001b[0m]: Blocking XREAD waiting new data in tests/unit/type/stream.tcl\r\nExpected [lindex  0 0] eq {s2} (context: type eval line 7 cmd {assert {[lindex $res 0 0] eq {s2}}} proc ::test)\r\n[\u001b[0;32;49mok\u001b[0m]: Blocking XREAD waiting old data\r\n[\u001b[0;32;49mok\u001b[0m]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=swapdb\r\n[\u001b[0;32;49mok\u001b[0m]: Blocking XREAD will not reply with an empty array\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD: XADD + DEL should not awake client\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD: XADD + DEL + LPUSH should not awake client\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of hash with hashtable encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of zset with ziplist encoding, string data\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: no backlog (diskless: no, disabled, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: AOF fsync always barrier issue\r\n[16/56 \u001b[0;33;49mdone\u001b[0m]: integration/aof (29 seconds)\r\n\u001b[1;37;49mTesting integration/rdb\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: RDB encoding loading test\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: Server started empty with non-existing RDB file\r\n[\u001b[0;32;49mok\u001b[0m]: Server started empty with empty RDB file\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of zset with skiplist encoding, string data\r\n[\u001b[0;31;49merr\u001b[0m]: XREAD with same stream name multiple times should work in tests/unit/type/stream.tcl\r\nExpected [lindex  0 0] eq {s2} (context: type eval line 7 cmd {assert {[lindex $res 0 0] eq {s2}}} proc ::test)\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD + multiple XADD inside transaction\r\n[\u001b[0;32;49mok\u001b[0m]: XDEL basic test\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of zset with ziplist encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: Test RDB stream encoding\r\n[\u001b[0;32;49mok\u001b[0m]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=disabled\r\n[\u001b[0;32;49mok\u001b[0m]: Server should not start if RDB file can't be open\r\n[\u001b[0;32;49mok\u001b[0m]: Server should not start if RDB is corrupted\r\n[\u001b[0;32;49mok\u001b[0m]: Replication: commands with many arguments (issue #1221)\r\n[\u001b[0;32;49mok\u001b[0m]: Test FLUSHALL aborts bgsave\r\n[\u001b[0;32;49mok\u001b[0m]: Replication of SPOP command -- alsoPropagate() API\r\n[\u001b[0;32;49mok\u001b[0m]: AOF rewrite of zset with skiplist encoding, int data\r\n[\u001b[0;32;49mok\u001b[0m]: BGREWRITEAOF is delayed if BGSAVE is in progress\r\n[\u001b[0;32;49mok\u001b[0m]: BGREWRITEAOF is refused if already in progress\r\n[17/56 \u001b[0;33;49mdone\u001b[0m]: unit/aofrw (105 seconds)\r\n\u001b[1;37;49mTesting integration/convert-zipmap-hash-on-load\u001b[0m\r\n[18/56 \u001b[0;33;49mdone\u001b[0m]: integration/replication-4 (54 seconds)\r\n\u001b[1;37;49mTesting integration/logging\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: ok after delay (diskless: no, disabled, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: RDB load zipmap hash: converts to ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: LTRIM stress testing - linkedlist\r\n[\u001b[0;32;49mok\u001b[0m]: Server is able to generate a stack trace on selected systems\r\n[19/56 \u001b[0;33;49mdone\u001b[0m]: integration/logging (3 seconds)\r\n\u001b[1;37;49mTesting integration/psync2\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-entries is exceeded\r\n[\u001b[0;32;49mok\u001b[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-value is exceeded\r\n[\u001b[0;32;49mok\u001b[0m]: SET 10000 numeric keys and access all them in reverse order\r\n[\u001b[0;32;49mok\u001b[0m]: DBSIZE should be 10000 now\r\n[\u001b[0;32;49mok\u001b[0m]: SETNX target key missing\r\n[\u001b[0;32;49mok\u001b[0m]: SETNX target key exists\r\n[\u001b[0;32;49mok\u001b[0m]: SETNX against not-expired volatile key\r\n[20/56 \u001b[0;33;49mdone\u001b[0m]: integration/convert-zipmap-hash-on-load (8 seconds)\r\n\u001b[1;37;49mTesting integration/psync2-reg\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: --- CYCLE 1 ---\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: [NEW LAYOUT] Set #2 as master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #4 to replicate from #2\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #0 to replicate from #4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #1 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #3 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: setup\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after failover\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=swapdb\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: generate load while killing replication links\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after load (x = 1516)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: --- CYCLE 2 ---\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: [NEW LAYOUT] Set #0 as master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #1 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #3 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #4 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #2 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after failover\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: backlog expired (diskless: no, disabled, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: generate load while killing replication links\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after load (x = 3374)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: --- CYCLE 3 ---\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: [NEW LAYOUT] Set #3 as master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #4 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #1 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #2 to replicate from #4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #0 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: no reconnection, just sync (diskless: no, swapdb, reconnect: 0)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYSCORE fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after failover\r\n[\u001b[0;32;49mok\u001b[0m]: XDEL fuzz test\r\n[\u001b[0;32;49mok\u001b[0m]: ZRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SDIFF fuzzing\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER against non-set should throw error\r\n[\u001b[0;32;49mok\u001b[0m]: SUNION against non-set should throw error\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER should handle non existing key as empty\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: SINTER with same integer elements but different encoding\r\n[\u001b[0;32;49mok\u001b[0m]: SINTERSTORE against non existing keys should delete dstkey\r\n[\u001b[0;32;49mok\u001b[0m]: SUNIONSTORE against non existing keys should delete dstkey\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP basics - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP with <count>=1 - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: SRANDMEMBER - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP basics - intset\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP with <count>=1 - intset\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: SRANDMEMBER - intset\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill first replica\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: kill chained replica\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP with <count>\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP with <count>\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP using integers, testing Knuth's and Floyd's algorithm\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP using integers with Knuth's algorithm\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP new implementation: code path #1\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP new implementation: code path #2\r\n[\u001b[0;32;49mok\u001b[0m]: SPOP new implementation: code path #3\r\n[\u001b[0;32;49mok\u001b[0m]: SRANDMEMBER with <count> against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: SRANDMEMBER with <count> - hashtable\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: SRANDMEMBER with <count> - intset\r\n[\u001b[0;32;49mok\u001b[0m]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE basics - from regular set to intset\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE basics - from intset to regular set\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE non existing src set\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE from regular set to non existing destination set\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE from intset to non existing destination set\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE wrong src key type\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE wrong dst key type\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: generate load while killing replication links\r\n[\u001b[0;32;49mok\u001b[0m]: SMOVE with identical source and destination\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 #3899 regression: verify consistency\r\n[\u001b[0;32;49mok\u001b[0m]: ZSETs skiplist implementation backlink consistency test - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after load (x = 4355)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: --- CYCLE 4 ---\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: [NEW LAYOUT] Set #3 as master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #2 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #0 to replicate from #2\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #4 to replicate from #2\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #1 to replicate from #3\r\n[21/56 \u001b[0;33;49mdone\u001b[0m]: integration/psync2-reg (27 seconds)\r\n\u001b[1;37;49mTesting integration/psync2-pingoff\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after failover\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 pingoff: setup\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 pingoff: write and wait replication\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: ok psync (diskless: no, swapdb, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: Old Big Linked list: SORT BY key\r\n[\u001b[0;32;49mok\u001b[0m]: Old Big Linked list: SORT BY key with limit\r\n[\u001b[0;32;49mok\u001b[0m]: Old Big Linked list: SORT BY hash field\r\n[\u001b[0;32;49mok\u001b[0m]: Intset: SORT BY key\r\n[\u001b[0;32;49mok\u001b[0m]: Intset: SORT BY key with limit\r\n[\u001b[0;32;49mok\u001b[0m]: Intset: SORT BY hash field\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: generate load while killing replication links\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after load (x = 5736)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: --- CYCLE 5 ---\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: [NEW LAYOUT] Set #4 as master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #0 to replicate from #4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #3 to replicate from #0\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #2 to replicate from #4\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Set #1 to replicate from #3\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2 pingoff: pause replica and promote it\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: Make the old master a replica of the new one and check conditions\r\n[\u001b[0;32;49mok\u001b[0m]: SETNX against expired volatile key\r\n[\u001b[0;32;49mok\u001b[0m]: MGET\r\n[\u001b[0;32;49mok\u001b[0m]: MGET against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: MGET against non-string key\r\n[\u001b[0;32;49mok\u001b[0m]: GETSET (set new value)\r\n[\u001b[0;32;49mok\u001b[0m]: GETSET (replace old value)\r\n[\u001b[0;32;49mok\u001b[0m]: MSET base case\r\n[\u001b[0;32;49mok\u001b[0m]: MSET wrong number of args\r\n[\u001b[0;32;49mok\u001b[0m]: MSETNX with already existent key\r\n[\u001b[0;32;49mok\u001b[0m]: MSETNX with not existing keys\r\n[\u001b[0;32;49mok\u001b[0m]: STRLEN against non-existing key\r\n[\u001b[0;32;49mok\u001b[0m]: STRLEN against integer-encoded value\r\n[\u001b[0;32;49mok\u001b[0m]: STRLEN against plain string\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT against non-existing key\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT against string-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT against integer-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT against key with wrong type\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT with out of range bit offset\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT with non-bit argument\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after failover\r\n[\u001b[0;32;49mok\u001b[0m]: MASTER and SLAVE consistency with expire\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: generate load while killing replication links\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: cluster is consistent after load (x = 6978)\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[\u001b[0;32;49mok\u001b[0m]: Hash table: SORT BY key\r\n[\u001b[0;32;49mok\u001b[0m]: Hash table: SORT BY key with limit\r\n[\u001b[0;32;49mok\u001b[0m]: Hash table: SORT BY hash field\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Bring the master back again for next test\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: no backlog (diskless: no, swapdb, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: XRANGE fuzzing\r\n[\u001b[0;32;49mok\u001b[0m]: XREVRANGE regression test for issue #5006\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD streamID edge (no-blocking)\r\n[\u001b[0;32;49mok\u001b[0m]: XREAD streamID edge (blocking)\r\n[\u001b[0;32;49mok\u001b[0m]: XADD streamID edge\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Partial resync after restart using RDB aux fields\r\n[\u001b[0;32;49mok\u001b[0m]: XADD with MAXLEN > xlen can propagate correctly\r\n[\u001b[0;32;49mok\u001b[0m]: PSYNC2: Replica RDB restart with EVALSHA in backlog issue #4483\r\n[\u001b[0;32;49mok\u001b[0m]: XADD with ~ MAXLEN can propagate correctly\r\n[\u001b[0;32;49mok\u001b[0m]: Slave is able to evict keys created in writable slaves\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[\u001b[0;32;49mok\u001b[0m]: test various edge cases of repl topology changes with missing pings at the end\r\n[\u001b[0;32;49mok\u001b[0m]: XTRIM with ~ MAXLEN can propagate correctly\r\n[\u001b[0;32;49mok\u001b[0m]: First server should have role slave after SLAVEOF\r\n[22/56 \u001b[0;33;49mdone\u001b[0m]: integration/psync2 (54 seconds)\r\n\u001b[1;37;49mTesting integration/redis-cli\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[\u001b[0;32;49mok\u001b[0m]: XADD can CREATE an empty stream\r\n[\u001b[0;32;49mok\u001b[0m]: XSETID can set a specific ID\r\n[\u001b[0;32;49mok\u001b[0m]: XSETID cannot SETID with smaller ID\r\n[\u001b[0;32;49mok\u001b[0m]: XSETID cannot SETID on non-existent key\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: INFO response should be printed raw\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: Status reply\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: Integer reply\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: Bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: Multi-bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: Interactive CLI: Parsing quotes\r\n[\u001b[0;32;49mok\u001b[0m]: SETBIT fuzzing\r\n[\u001b[0;32;49mok\u001b[0m]: GETBIT against non-existing key\r\n[\u001b[0;32;49mok\u001b[0m]: GETBIT against string-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: GETBIT against integer-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Status reply\r\n[\u001b[0;32;49mok\u001b[0m]: SETRANGE against non-existing key\r\n[\u001b[0;32;49mok\u001b[0m]: SETRANGE against string-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Integer reply\r\n[\u001b[0;32;49mok\u001b[0m]: SETRANGE against integer-encoded key\r\n[\u001b[0;32;49mok\u001b[0m]: SETRANGE against key with wrong type\r\n[\u001b[0;32;49mok\u001b[0m]: SETRANGE with out of range offset\r\n[\u001b[0;32;49mok\u001b[0m]: GETRANGE against non-existing key\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: GETRANGE against string value\r\n[\u001b[0;32;49mok\u001b[0m]: GETRANGE against integer-encoded value\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Multi-bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Read last argument from pipe\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive TTY CLI: Read last argument from file\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Status reply\r\n[\u001b[0;32;49mok\u001b[0m]: Empty stream can be rewrite into AOF correctly\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Integer reply\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Multi-bulk reply\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Read last argument from pipe\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Read last argument from file\r\n[\u001b[0;32;49mok\u001b[0m]: Stream can be rewrite into AOF correctly after XDEL lastid\r\n[\u001b[0;32;49mok\u001b[0m]: client freed during loading\r\n[23/56 \u001b[0;33;49mdone\u001b[0m]: integration/rdb (79 seconds)\r\n\u001b[1;37;49mTesting unit/pubsub\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: XGROUP HELP should not have unexpected options\r\n[\u001b[0;32;49mok\u001b[0m]: Pub/Sub PING\r\n[\u001b[0;32;49mok\u001b[0m]: PUBLISH/SUBSCRIBE basics\r\n[\u001b[0;32;49mok\u001b[0m]: PUBLISH/SUBSCRIBE with two clients\r\n[\u001b[0;31;49merr\u001b[0m]: PUBLISH/SUBSCRIBE after UNSUBSCRIBE without arguments in tests/unit/pubsub.tcl\r\nExpected '0' to be equal to '1' (context: type eval line 5 cmd {assert_equal 0 [r publish chan1 hello]} proc ::test)\r\n[\u001b[0;32;49mok\u001b[0m]: SUBSCRIBE to one channel more than once\r\n[\u001b[0;32;49mok\u001b[0m]: UNSUBSCRIBE from non-subscribed channels\r\n[\u001b[0;32;49mok\u001b[0m]: PUBLISH/PSUBSCRIBE basics\r\n[\u001b[0;32;49mok\u001b[0m]: PUBLISH/PSUBSCRIBE with two clients\r\n[\u001b[0;31;49merr\u001b[0m]: PUBLISH/PSUBSCRIBE after PUNSUBSCRIBE without arguments in tests/unit/pubsub.tcl\r\nExpected '0' to be equal to '1' (context: type eval line 5 cmd {assert_equal 0 [r publish chan1.hi hello]} proc ::test)\r\n[\u001b[0;32;49mok\u001b[0m]: PUNSUBSCRIBE from non-subscribed channels\r\n[\u001b[0;32;49mok\u001b[0m]: NUMSUB returns numbers, not strings (#1561)\r\n[\u001b[0;32;49mok\u001b[0m]: Mix SUBSCRIBE and PSUBSCRIBE\r\n[\u001b[0;32;49mok\u001b[0m]: PUNSUBSCRIBE and UNSUBSCRIBE should always reply\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: we receive keyspace notifications\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: we receive keyevent notifications\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: we can receive both kind of events\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: we are able to mask events\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: general events test\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: list events test\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: set events test\r\n[24/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/stream (177 seconds)\r\n\u001b[1;37;49mTesting unit/slowlog\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: zset events test\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: hash events test\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: expired events (triggered expire)\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: expired events (background expire)\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: evicted events\r\n[\u001b[0;32;49mok\u001b[0m]: Keyspace notifications: test CONFIG GET/SET of event flags\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - check that it starts with an empty log\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - only logs commands taking more time than specified\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - max entries is correctly handled\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - GET optional argument to limit output len works\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - RESET subcommand works\r\n[25/56 \u001b[0;33;49mdone\u001b[0m]: unit/pubsub (3 seconds)\r\n\u001b[1;37;49mTesting unit/scripting\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - logged entry sanity check\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - commands with too many arguments are trimmed\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - too long arguments are trimmed\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - EXEC is not logged, just executed commands\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - can clean older entires\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Does Lua interpreter replies to our requests?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua integer -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua string -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua true boolean -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua false boolean -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua status code reply -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua error reply -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Lua table -> Redis protocol type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Are the KEYS and ARGV arrays populated correctly?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - is Lua able to call Redis API?\r\n[\u001b[0;32;49mok\u001b[0m]: ZSETs ZRANK augmented skip list stress testing - ziplist\r\n[\u001b[0;32;49mok\u001b[0m]: EVALSHA - Can we call a SHA1 if already defined?\r\n[\u001b[0;32;49mok\u001b[0m]: EVALSHA - Can we call a SHA1 in uppercase?\r\n[\u001b[0;32;49mok\u001b[0m]: EVALSHA - Do we get an error on invalid SHA1?\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOPMIN, ZADD + DEL should not awake blocked client\r\n[\u001b[0;32;49mok\u001b[0m]: EVALSHA - Do we get an error on non defined SHA1?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis integer -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis bulk -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis multi bulk -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis status reply -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis error reply -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Redis nil bulk reply -> Lua type conversion\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Is the Lua client using the currently selected DB?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - SELECT inside Lua should not affect the caller\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOPMIN with same key multiple times should work\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Scripts can't run certain commands\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Scripts can't run XREAD and XREADGROUP with BLOCK option\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Scripts can't run certain commands\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - No arguments to redis.call/pcall is considered an error\r\n[\u001b[0;32;49mok\u001b[0m]: MULTI/EXEC is isolated from the point of view of BZPOPMIN\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOPMIN with variadic ZADD\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - JSON numeric decoding\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - JSON string decoding\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - cmsgpack can pack double?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - cmsgpack can pack negative int64?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - cmsgpack can pack and unpack circular references?\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Numerical sanity check from bitop\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Verify minimal bitop functionality\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL - Able to parse trailing comments\r\n[\u001b[0;32;49mok\u001b[0m]: SCRIPTING FLUSH - is able to clear the scripts cache?\r\n[\u001b[0;32;49mok\u001b[0m]: SCRIPT EXISTS - can detect already defined scripts?\r\n[\u001b[0;32;49mok\u001b[0m]: SCRIPT LOAD - is able to register scripts in the scripting cache\r\n[\u001b[0;32;49mok\u001b[0m]: In the context of Lua the output of random commands gets ordered\r\n[\u001b[0;32;49mok\u001b[0m]: SORT is normally not alpha re-ordered for the scripting engine\r\n[\u001b[0;32;49mok\u001b[0m]: SORT BY <constant> output gets ordered for scripting\r\n[\u001b[0;32;49mok\u001b[0m]: SORT BY <constant> with GET gets ordered for scripting\r\n[\u001b[0;32;49mok\u001b[0m]: SLOWLOG - can be disabled\r\n[\u001b[0;32;49mok\u001b[0m]: redis.sha1hex() implementation\r\n[\u001b[0;32;49mok\u001b[0m]: Globals protection reading an undeclared global variable\r\n[\u001b[0;32;49mok\u001b[0m]: Globals protection setting an undeclared global*\r\n[\u001b[0;32;49mok\u001b[0m]: Test an example script DECR_IF_GT\r\n[\u001b[0;32;49mok\u001b[0m]: Scripting engine resets PRNG at every script execution\r\n[\u001b[0;32;49mok\u001b[0m]: Scripting engine PRNG can be seeded correctly\r\n[\u001b[0;32;49mok\u001b[0m]: Chained replicas disconnect when replica re-connect with the same master\r\n[\u001b[0;32;49mok\u001b[0m]: Master stream is correctly processed while the replica has a script in -BUSY state\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Dumping an RDB\r\n[\u001b[0;32;49mok\u001b[0m]: BZPOPMIN with zero timeout should block indefinitely\r\n[26/56 \u001b[0;33;49mdone\u001b[0m]: unit/slowlog (3 seconds)\r\n\u001b[1;37;49mTesting unit/maxmemory\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Test replication partial resync: ok after delay (diskless: no, swapdb, reconnect: 1)\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL does not leak in the Lua stack\r\n[\u001b[0;32;49mok\u001b[0m]: Without maxmemory small integers are shared\r\n[\u001b[0;32;49mok\u001b[0m]: With maxmemory and non-LRU policy integers are still shared\r\n[\u001b[0;32;49mok\u001b[0m]: With maxmemory and LRU policy integers are not shared\r\n[\u001b[0;32;49mok\u001b[0m]: EVAL processes writes from AOF in read-only slaves\r\n[\u001b[0;32;49mok\u001b[0m]: We can call scripts rewriting client->argv from Lua\r\n[\u001b[0;32;49mok\u001b[0m]: Call Redis command with many args from Lua (issue #1764)\r\n[\u001b[0;32;49mok\u001b[0m]: Number conversion precision test (issue #1118)\r\n[\u001b[0;32;49mok\u001b[0m]: String containing number precision test (regression of issue #1118)\r\n[\u001b[0;32;49mok\u001b[0m]: SCAN regression test for issue #4906\r\n[\u001b[0;32;49mok\u001b[0m]: Verify negative arg count is error instead of crash (issue #1842)\r\n[\u001b[0;32;49mok\u001b[0m]: Correct handling of reused argv (issue #1939)\r\n[\u001b[0;32;49mok\u001b[0m]: Functions in the Redis namespace are able to report errors\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCORE - skiplist\r\n[27/56 \u001b[0;33;49mdone\u001b[0m]: unit/scan (181 seconds)\r\n\u001b[1;37;49mTesting unit/introspection\u001b[0m\r\n[28/56 \u001b[0;33;49mdone\u001b[0m]: integration/psync2-pingoff (35 seconds)\r\n\u001b[1;37;49mTesting unit/introspection-2\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT LIST\r\n[\u001b[0;32;49mok\u001b[0m]: MONITOR can log executed commands\r\n[\u001b[0;32;49mok\u001b[0m]: MONITOR can log commands issued by the scripting engine\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT GETNAME should return NIL if name is not assigned\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT LIST shows empty fields for unassigned names\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT SETNAME does not accept spaces\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT SETNAME can assign a name to this connection\r\n[\u001b[0;32;49mok\u001b[0m]: CLIENT SETNAME can change the name of an existing connection\r\n[\u001b[0;32;49mok\u001b[0m]: After CLIENT SETNAME, connection can still be closed\r\n[\u001b[0;32;49mok\u001b[0m]: ZSCORE after a DEBUG RELOAD - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: CONFIG sanity\r\n[\u001b[0;32;49mok\u001b[0m]: Non-interactive non-TTY CLI: Connecting as a replica\r\n[\u001b[0;32;49mok\u001b[0m]: Timedout read-only scripts can be killed by SCRIPT KILL\r\n[\u001b[0;32;49mok\u001b[0m]: GETRANGE fuzzing\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET can detect syntax errors\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET NX option\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET XX option\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET EX option\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET PX option\r\n[\u001b[0;32;49mok\u001b[0m]: Extended SET using multiple options at once\r\n[\u001b[0;32;49mok\u001b[0m]: GETRANGE with huge ranges, Github issue #1844\r\n[\u001b[0;32;49mok\u001b[0m]: STRALGO LCS string output with STRINGS option\r\n[\u001b[0;32;49mok\u001b[0m]: STRALGO LCS len\r\n[\u001b[0;32;49mok\u001b[0m]: LCS with KEYS option\r\n[\u001b[0;32;49mok\u001b[0m]: LCS indexes\r\n[\u001b[0;32;49mok\u001b[0m]: LCS indexes with match len\r\n[\u001b[0;32;49mok\u001b[0m]: LCS indexes with match len and minimum match len\r\n[\u001b[0;32;49mok\u001b[0m]: Timedout script link is still usable after Lua returns\r\n[29/56 \u001b[0;33;49mdone\u001b[0m]: unit/introspection (3 seconds)\r\n\u001b[1;37;49mTesting unit/limits\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: ZSET sorting stresser - skiplist\r\n[\u001b[0;32;49mok\u001b[0m]: Timedout scripts that modified data can't be killed by SCRIPT KILL\r\n[\u001b[0;32;49mok\u001b[0m]: SHUTDOWN NOSAVE can kill a timedout script anyway\r\n[\u001b[0;32;49mok\u001b[0m]: Slave should be able to synchronize with the master\r\n[30/56 \u001b[0;33;49mdone\u001b[0m]: unit/type/string (184 seconds)\r\n\u001b[1;37;49mTesting unit/obuf-limits\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Check if maxclients works refusing connections\r\n[\u001b[0;32;49mok\u001b[0m]: Before the replica connects we issue two EVAL commands (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: TTL and TYPYE do not alter the last access time of a key\r\n[\u001b[0;32;49mok\u001b[0m]: maxmemory - is the memory limit honoured? (policy allkeys-random)\r\n[\u001b[0;32;49mok\u001b[0m]: Detect write load to master\r\n[31/56 \u001b[0;33;49mdone\u001b[0m]: unit/limits (2 seconds)\r\n\u001b[1;37;49mTesting unit/bitops\u001b[0m\r\n[\u001b[0;32;49mok\u001b[0m]: Connect a replica to the master instance (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: Now use EVALSHA against the master, with both SHAs (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: If EVALSHA was replicated as EVAL, 'x' should be '4' (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: Replication of script multiple pushes to list with BLPOP (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: EVALSHA replication when first call is readonly (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT returns 0 against non existing key\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT returns 0 with out of range indexes\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT returns 0 with negative indexes where start > end\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT against test vector #1\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT against test vector #2\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT against test vector #3\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT against test vector #4\r\n[\u001b[0;32;49mok\u001b[0m]: Lua scripts using SELECT are replicated correctly (scripts replication)\r\n[\u001b[0;32;49mok\u001b[0m]: BITCOUNT against test vector #5\r\n\r\nLogged warnings (pid 4778):\r\n(none)\r\n\r\n[\u001b[0;31;49mexception\u001b[0m]: Executing test client: error writing \"file70\": broken pipe.\r\nerror writing \"file70\": broken pipe\r\n    while executing\r\n\"$client set large-key [string repeat \"x\" 20000]\"\r\n    (\"uplevel\" body line 13)\r\n    invoked from within\r\n\"uplevel 1 $code\"\r\n    (procedure \"test\" line 47)\r\n    invoked from within\r\n\"test \"Non-interactive non-TTY CLI: $name\" $code\"\r\n    (procedure \"test_nontty_cli\" line 2)\r\n    invoked from within\r\n\"test_nontty_cli \"Piping raw protocol\" {\r\n        set fd [open_cli \"--pipe\"]\r\n        fconfigure $fd -blocking true\r\n\r\n        # Create a new deferring cli...\"\r\n    (\"uplevel\" body line 259)\r\n    invoked from within\r\n\"uplevel 1 $code \"\r\n    (procedure \"start_server\" line 3)\r\n    invoked from within\r\n\"start_server {tags {\"cli\"}} {\r\n    proc open_cli {{opts \"-n 9\"}} {\r\n        set ::env(TERM) dumb\r\n        set cmdline [rediscli [srv port] $opts]\r\n       ...\"\r\n    (file \"tests/integration/redis-cli.tcl\" line 3)\r\n    invoked from within\r\n\"source $path\"\r\n    (procedure \"execute_test_file\" line 4)\r\n    invoked from within\r\n\"execute_test_file $data\"\r\n    (procedure \"test_client_main\" line 10)\r\n    invoked from within\r\n\"test_client_main $::test_server_port \"\r\nKilling still running Redis server 2572\r\nKilling still running Redis server 2574\r\nKilling still running Redis server 2583\r\nKilling still running Redis server 2576\r\nKilling still running Redis server 2617\r\nKilling still running Redis server 2741\r\nKilling still running Redis server 3073\r\nKilling still running Redis server 3083\r\nKilling still running Redis server 3548\r\nKilling still running Redis server 3558\r\nKilling still running Redis server 3567\r\nKilling still running Redis server 3925\r\nKilling still running Redis server 3938\r\nKilling still running Redis server 4118\r\nKilling still running Redis server 4722\r\nKilling still running Redis server 4745\r\nKilling still running Redis server 4951\r\nKilling still running Redis server 5006\r\nKilling still running Redis server 5015\r\nKilling still running Redis server 5034\r\nKilling still running Redis server 5042\r\nKilling still running Redis server 5070\r\nKilling still running Redis server 5108\r\nKilling still running Redis server 5115\r\nKilling still running Redis server 5130\r\nKilling still running Redis server 5153\r\nMakefile:330: recipe for target 'test' failed\r\nmake[1]: Leaving directory '/home/toby/make-redis/redis-stable/src'\r\nMakefile:6: recipe for target 'test' failed\r\n```\r\n</details>",
  "state": "open",
  "created_at": "2020-08-24T15:50:12Z",
  "updated_at": "2020-08-28T14:54:23Z",
  "closed_at": null,
  "labels": [],
  "comments_data": [
    {
      "id": 679337874,
      "user": "oranagra",
      "created_at": "2020-08-24T20:04:33Z",
      "body": "@wolf99 which version of tcl do you have?\r\nthis could be due to https://github.com/redis/redis/pull/7548\r\ncan you test the unstable branch?"
    },
    {
      "id": 679847027,
      "user": "wolf99",
      "created_at": "2020-08-25T07:10:13Z",
      "body": "```\r\n$ tclsh\r\n% info patchlevel\r\n8.6.8\r\n```\r\n\r\nIf I read #7548 correctly, this version of Tcl means I shouldn't see that problem?"
    },
    {
      "id": 679849954,
      "user": "oranagra",
      "created_at": "2020-08-25T07:17:24Z",
      "body": "yes. but maybe that's another side effect fixed by the new approach.\r\ncan you test `unstable` anyway?"
    },
    {
      "id": 681960958,
      "user": "wolf99",
      "created_at": "2020-08-27T13:49:46Z",
      "body": "Have run with unstable. Still seeing an error, hopefully there is some more information in this time.\r\n\r\n<details>\r\n<summary>logged test output:</summary>\r\n\r\n```\r\n$ make test\r\ncd src && make test\r\nmake[1]: Entering directory '/mnt/c/Users/emoltob/git/redis/src'\r\n    CC Makefile.dep\r\nrm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-rdb redis-check-aof *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark\r\nrm -f adlist.d quicklist.d ae.d anet.d dict.d server.d sds.d zmalloc.d lzf_c.d lzf_d.d pqsort.d zipmap.d sha1.d ziplist.d release.d networking.d util.d object.d db.d replication.d rdb.d t_string.d t_list.d t_set.d t_zset.d t_hash.d config.d aof.d pubsub.d multi.d debug.d sort.d intset.d syncio.d cluster.d crc16.d endianconv.d slowlog.d scripting.d bio.d rio.d rand.d memtest.d crcspeed.d crc64.d bitops.d sentinel.d notify.d setproctitle.d blocked.d hyperloglog.d latency.d sparkline.d redis-check-rdb.d redis-check-aof.d geo.d lazyfree.d module.d evict.d expire.d geohash.d geohash_helper.d childinfo.d defrag.d siphash.d rax.d t_stream.d listpack.d localtime.d lolwut.d lolwut5.d\r\nlolwut6.d acl.d gopher.d tracking.d connection.d tls.d sha256.d timeout.d setcpuaffinity.d anet.d adlist.d dict.d\r\nredis-cli.d zmalloc.d release.d ae.d crcspeed.d crc64.d siphash.d crc16.d ae.d anet.d redis-benchmark.d adlist.d dict.d zmalloc.d siphash.d\r\n(cd ../deps && make distclean)\r\nmake[2]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps'\r\n(cd hiredis && make clean) > /dev/null || true\r\n(cd linenoise && make clean) > /dev/null || true\r\n(cd lua && make clean) > /dev/null || true\r\n(cd jemalloc && [ -f Makefile ] && make distclean) > /dev/null || true\r\n(cd hdr_histogram && make clean) > /dev/null || true\r\n(rm -f .make-*)\r\nmake[2]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps'\r\n(rm -f .make-*)\r\necho STD=-std=c11 -pedantic -DREDIS_STATIC='' >> .make-settings\r\necho WARN=-Wall -W -Wno-missing-field-initializers >> .make-settings\r\necho OPT=-O2 >> .make-settings\r\necho MALLOC=jemalloc >> .make-settings\r\necho CFLAGS= >> .make-settings\r\necho LDFLAGS= >> .make-settings\r\necho REDIS_CFLAGS= >> .make-settings\r\necho REDIS_LDFLAGS= >> .make-settings\r\necho PREV_FINAL_CFLAGS=-std=c11 -pedantic -DREDIS_STATIC='' -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb\r\n  -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -I../deps/hdr_histogram -DUSE_JEMALLOC -I../deps/jemalloc/include >> .make-settings\r\necho PREV_FINAL_LDFLAGS=  -g -ggdb -rdynamic >> .make-settings\r\n(cd ../deps && make hiredis linenoise lua hdr_histogram jemalloc)\r\nmake[2]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps'\r\n(cd hiredis && make clean) > /dev/null || true\r\n(cd linenoise && make clean) > /dev/null || true\r\n(cd lua && make clean) > /dev/null || true\r\n(cd jemalloc && [ -f Makefile ] && make distclean) > /dev/null || true\r\n(cd hdr_histogram && make clean) > /dev/null || true\r\n(rm -f .make-*)\r\n(echo \"\" > .make-cflags)\r\n(echo \"\" > .make-ldflags)\r\nMAKE hiredis\r\ncd hiredis && make static\r\nmake[3]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps/hiredis'\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb alloc.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb net.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb hiredis.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb sds.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb async.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb read.c\r\ncc -std=c99 -pedantic -c -O3 -fPIC   -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers\r\n-g -ggdb sockcompat.c\r\nar rcs libhiredis.a alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o\r\nmake[3]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps/hiredis'\r\nMAKE linenoise\r\ncd linenoise && make\r\nmake[3]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps/linenoise'\r\ncc  -Wall -Os -g  -c linenoise.c\r\nmake[3]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps/linenoise'\r\nMAKE lua\r\ncd lua/src && make all CFLAGS=\"-O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' \" MYLDFLAGS=\"\" AR=\"ar\r\nrcu\"\r\nmake[3]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps/lua/src'\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lapi.o lapi.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lcode.o lcode.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ldebug.o ldebug.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ldo.o ldo.c\r\nldo.c: In function f_parser:\r\nldo.c:496:7: warning: unused variable c [-Wunused-variable]\r\n   int c = luaZ_lookahead(p->z);\r\n       ^\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ldump.o ldump.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lfunc.o lfunc.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lgc.o lgc.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o llex.o llex.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lmem.o lmem.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lobject.o lobject.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lopcodes.o lopcodes.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lparser.o lparser.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lstate.o lstate.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lstring.o lstring.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ltable.o ltable.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ltm.o ltm.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lundump.o lundump.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lvm.o lvm.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lzio.o lzio.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o strbuf.o strbuf.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o fpconv.o fpconv.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lauxlib.o lauxlib.c\r\nlauxlib.c: In function luaL_loadfile:\r\nlauxlib.c:577:4: warning: this while clause does not guard... [-Wmisleading-indentation]\r\n    while ((c = getc(lf.f)) != EOF && c != LUA_SIGNATURE[0]) ;\r\n    ^~~~~\r\nlauxlib.c:578:5: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the while\r\n     lf.extraline = 0;\r\n     ^~\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lbaselib.o lbaselib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ldblib.o ldblib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o liolib.o liolib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lmathlib.o lmathlib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o loslib.o loslib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o ltablib.o ltablib.c\r\nltablib.c: In function addfield:\r\nltablib.c:137:3: warning: this if clause does not guard... [-Wmisleading-indentation]\r\n   if (!lua_isstring(L, -1))\r\n   ^~\r\nltablib.c:140:5: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the i\r\n\r\n     luaL_addvalue(b);\r\n     ^~~~~~~~~~~~~\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lstrlib.o lstrlib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o loadlib.o loadlib.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o linit.o linit.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lua_cjson.o lua_cjson.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lua_struct.o lua_struct.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lua_cmsgpack.o lua_cmsgpack.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lua_bit.o lua_bit.c\r\nar rcu liblua.a lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o lundump.o lvm.o lzio.o strbuf.o fpconv.o lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o loadlib.o linit.o lua_cjson.o lua_struct.o lua_cmsgpack.o lua_bit.o      #\r\nDLL needs all object files\r\nar: `u' modifier ignored since `D' is the default (see `U')\r\nranlib liblua.a\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o lua.o lua.c\r\ncc -o lua  lua.o liblua.a -lm\r\nliblua.a(loslib.o): In function `os_tmpname':\r\nloslib.c:(.text+0x290): warning: the use of `tmpnam' is dangerous, better use `mkstemp'\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o luac.o luac.c\r\ncc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC=''    -c -o print.o print.c\r\ncc -o luac  luac.o print.o liblua.a -lm\r\nmake[3]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps/lua/src'\r\nMAKE hdr_histogram\r\ncd hdr_histogram && make\r\nmake[3]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps/hdr_histogram'\r\ncc  -Wall -Os -g  -c  hdr_histogram.c\r\nmake[3]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps/hdr_histogram'\r\nMAKE jemalloc\r\ncd jemalloc && ./configure --with-version=5.1.0-0-g0 --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS=\"-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops \" LDFLAGS=\"\"\r\nconfigure: WARNING: unrecognized options: --enable-cc-silence\r\nchecking for xsltproc... false\r\nchecking for gcc... gcc\r\nchecking whether the C compiler works... yes\r\nchecking for C compiler default output file name... a.out\r\nchecking for suffix of executables...\r\nchecking whether we are cross compiling... no\r\nchecking for suffix of object files... o\r\nchecking whether we are using the GNU C compiler... yes\r\nchecking whether gcc accepts -g... yes\r\nchecking for gcc option to accept ISO C89... none needed\r\nchecking whether compiler is cray... no\r\nchecking whether compiler supports -std=gnu11... yes\r\nchecking whether compiler supports -Wall... yes\r\nchecking whether compiler supports -Wshorten-64-to-32... no\r\nchecking whether compiler supports -Wsign-compare... yes\r\nchecking whether compiler supports -Wundef... yes\r\nchecking whether compiler supports -Wno-format-zero-length... yes\r\nchecking whether compiler supports -pipe... yes\r\nchecking whether compiler supports -g3... yes\r\nchecking how to run the C preprocessor... gcc -E\r\nchecking for g++... g++\r\nchecking whether we are using the GNU C++ compiler... yes\r\nchecking whether g++ accepts -g... yes\r\nchecking whether g++ supports C++14 features by default... yes\r\nchecking whether compiler supports -Wall... yes\r\nchecking whether compiler supports -g3... yes\r\nchecking whether libstdc++ linkage is compilable... yes\r\nchecking for grep that handles long lines and -e... /bin/grep\r\nchecking for egrep... /bin/grep -E\r\nchecking for ANSI C header files... yes\r\nchecking for sys/types.h... yes\r\nchecking for sys/stat.h... yes\r\nchecking for stdlib.h... yes\r\nchecking for string.h... yes\r\nchecking for memory.h... yes\r\nchecking for strings.h... yes\r\nchecking for inttypes.h... yes\r\nchecking for stdint.h... yes\r\nchecking for unistd.h... yes\r\nchecking whether byte ordering is bigendian... no\r\nchecking size of void *... 8\r\nchecking size of int... 4\r\nchecking size of long... 8\r\nchecking size of long long... 8\r\nchecking size of intmax_t... 8\r\nchecking build system type... x86_64-pc-linux-gnu\r\nchecking host system type... x86_64-pc-linux-gnu\r\nchecking whether pause instruction is compilable... yes\r\nchecking number of significant virtual address bits... 48\r\nchecking for ar... ar\r\nchecking for nm... nm\r\nchecking for gawk... gawk\r\nchecking malloc.h usability... yes\r\nchecking malloc.h presence... yes\r\nchecking for malloc.h... yes\r\nchecking whether malloc_usable_size definition can use const argument... no\r\nchecking for library containing log... -lm\r\nchecking whether __attribute__ syntax is compilable... yes\r\nchecking whether compiler supports -fvisibility=hidden... yes\r\nchecking whether compiler supports -fvisibility=hidden... yes\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether compiler supports -herror_on_warning... no\r\nchecking whether tls_model attribute is compilable... yes\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether compiler supports -herror_on_warning... no\r\nchecking whether alloc_size attribute is compilable... yes\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether compiler supports -herror_on_warning... no\r\nchecking whether format(gnu_printf, ...) attribute is compilable... yes\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether compiler supports -herror_on_warning... no\r\nchecking whether format(printf, ...) attribute is compilable... yes\r\nchecking for a BSD-compatible install... /usr/bin/install -c\r\nchecking for ranlib... ranlib\r\nchecking for ld... /usr/bin/ld\r\nchecking for autoconf... false\r\nchecking for memalign... yes\r\nchecking for valloc... yes\r\nchecking whether compiler supports -O3... yes\r\nchecking whether compiler supports -O3... yes\r\nchecking whether compiler supports -funroll-loops... yes\r\nchecking configured backtracing method... N/A\r\nchecking for sbrk... yes\r\nchecking whether utrace(2) is compilable... no\r\nchecking whether a program using __builtin_unreachable is compilable... yes\r\nchecking whether a program using __builtin_ffsl is compilable... yes\r\nchecking LG_PAGE... 12\r\nchecking pthread.h usability... yes\r\nchecking pthread.h presence... yes\r\nchecking for pthread.h... yes\r\nchecking for pthread_create in -lpthread... yes\r\nchecking dlfcn.h usability... yes\r\nchecking dlfcn.h presence... yes\r\nchecking for dlfcn.h... yes\r\nchecking for dlsym... no\r\nchecking for dlsym in -ldl... yes\r\nchecking whether pthread_atfork(3) is compilable... yes\r\nchecking whether pthread_setname_np(3) is compilable... yes\r\nchecking for library containing clock_gettime... none required\r\nchecking whether clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is compilable... yes\r\nchecking whether clock_gettime(CLOCK_MONOTONIC, ...) is compilable... yes\r\nchecking whether mach_absolute_time() is compilable... no\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether syscall(2) is compilable... yes\r\nchecking for secure_getenv... yes\r\nchecking for sched_getcpu... yes\r\nchecking for sched_setaffinity... yes\r\nchecking for issetugid... no\r\nchecking for _malloc_thread_cleanup... no\r\nchecking for _pthread_mutex_init_calloc_cb... no\r\nchecking for TLS... yes\r\nchecking whether C11 atomics is compilable... no\r\nchecking whether GCC __atomic atomics is compilable... yes\r\nchecking whether GCC __sync atomics is compilable... yes\r\nchecking whether Darwin OSAtomic*() is compilable... no\r\nchecking whether madvise(2) is compilable... yes\r\nchecking whether madvise(..., MADV_FREE) is compilable... yes\r\nchecking whether madvise(..., MADV_DONTNEED) is compilable... yes\r\nchecking whether madvise(..., MADV_DO[NT]DUMP) is compilable... yes\r\nchecking whether madvise(..., MADV_[NO]HUGEPAGE) is compilable... yes\r\nchecking whether to force 32-bit __sync_{add,sub}_and_fetch()... no\r\nchecking whether to force 64-bit __sync_{add,sub}_and_fetch()... no\r\nchecking for __builtin_clz... yes\r\nchecking whether Darwin os_unfair_lock_*() is compilable... no\r\nchecking whether Darwin OSSpin*() is compilable... no\r\nchecking whether glibc malloc hook is compilable... yes\r\nchecking whether glibc memalign hook is compilable... yes\r\nchecking whether pthreads adaptive mutexes is compilable... yes\r\nchecking whether compiler supports -D_GNU_SOURCE... yes\r\nchecking whether compiler supports -Werror... yes\r\nchecking whether compiler supports -herror_on_warning... no\r\nchecking whether strerror_r returns char with gnu source is compilable... yes\r\nchecking for stdbool.h that conforms to C99... yes\r\nchecking for _Bool... yes\r\nconfigure: creating ./config.status\r\nconfig.status: creating Makefile\r\nconfig.status: creating jemalloc.pc\r\nconfig.status: creating doc/html.xsl\r\nconfig.status: creating doc/manpages.xsl\r\nconfig.status: creating doc/jemalloc.xml\r\nconfig.status: creating include/jemalloc/jemalloc_macros.h\r\nconfig.status: creating include/jemalloc/jemalloc_protos.h\r\nconfig.status: creating include/jemalloc/jemalloc_typedefs.h\r\nconfig.status: creating include/jemalloc/internal/jemalloc_preamble.h\r\nconfig.status: creating test/test.sh\r\nconfig.status: creating test/include/test/jemalloc_test.h\r\nconfig.status: creating config.stamp\r\nconfig.status: creating bin/jemalloc-config\r\nconfig.status: creating bin/jemalloc.sh\r\nconfig.status: creating bin/jeprof\r\nconfig.status: creating include/jemalloc/jemalloc_defs.h\r\nconfig.status: creating include/jemalloc/internal/jemalloc_internal_defs.h\r\nconfig.status: creating test/include/test/jemalloc_test_defs.h\r\nconfig.status: executing include/jemalloc/internal/public_symbols.txt commands\r\nconfig.status: executing include/jemalloc/internal/private_symbols.awk commands\r\nconfig.status: executing include/jemalloc/internal/private_symbols_jet.awk commands\r\nconfig.status: executing include/jemalloc/internal/public_namespace.h commands\r\nconfig.status: executing include/jemalloc/internal/public_unnamespace.h commands\r\nconfig.status: executing include/jemalloc/internal/size_classes.h commands\r\nconfig.status: executing include/jemalloc/jemalloc_protos_jet.h commands\r\nconfig.status: executing include/jemalloc/jemalloc_rename.h commands\r\nconfig.status: executing include/jemalloc/jemalloc_mangle.h commands\r\nconfig.status: executing include/jemalloc/jemalloc_mangle_jet.h commands\r\nconfig.status: executing include/jemalloc/jemalloc.h commands\r\nconfigure: WARNING: unrecognized options: --enable-cc-silence\r\n===============================================================================\r\njemalloc version   : 5.1.0-0-g0\r\nlibrary revision   : 2\r\n\r\nCONFIG             : --with-version=5.1.0-0-g0 --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence\r\n'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS=\r\nCC                 : gcc\r\nCONFIGURE_CFLAGS   : -std=gnu11 -Wall -Wsign-compare -Wundef -Wno-format-zero-length -pipe -g3 -fvisibility=hidden -O3 -funroll-loops\r\nSPECIFIED_CFLAGS   : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops\r\nEXTRA_CFLAGS       :\r\nCPPFLAGS           : -D_GNU_SOURCE -D_REENTRANT\r\nCXX                : g++\r\nCONFIGURE_CXXFLAGS : -Wall -g3 -fvisibility=hidden -O3\r\nSPECIFIED_CXXFLAGS :\r\nEXTRA_CXXFLAGS     :\r\nLDFLAGS            :\r\nEXTRA_LDFLAGS      :\r\nDSO_LDFLAGS        : -shared -Wl,-soname,$(@F)\r\nLIBS               : -lm -lstdc++ -lpthread -ldl\r\nRPATH_EXTRA        :\r\n\r\nXSLTPROC           : false\r\nXSLROOT            :\r\n\r\nPREFIX             : /usr/local\r\nBINDIR             : /usr/local/bin\r\nDATADIR            : /usr/local/share\r\nINCLUDEDIR         : /usr/local/include\r\nLIBDIR             : /usr/local/lib\r\nMANDIR             : /usr/local/share/man\r\n\r\nsrcroot            :\r\nabs_srcroot        : /home/toby/git/redis/deps/jemalloc/\r\nobjroot            :\r\nabs_objroot        : /home/toby/git/redis/deps/jemalloc/\r\n\r\nJEMALLOC_PREFIX    : je_\r\nJEMALLOC_PRIVATE_NAMESPACE\r\n                   : je_\r\ninstall_suffix     :\r\nmalloc_conf        :\r\nautogen            : 0\r\ndebug              : 0\r\nstats              : 1\r\nprof               : 0\r\nprof-libunwind     : 0\r\nprof-libgcc        : 0\r\nprof-gcc           : 0\r\nfill               : 1\r\nutrace             : 0\r\nxmalloc            : 0\r\nlog                : 0\r\nlazy_lock          : 0\r\ncache-oblivious    : 1\r\ncxx                : 1\r\n===============================================================================\r\ncd jemalloc && make CFLAGS=\"-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops \" LDFLAGS=\"\" lib/libjemalloc.a\r\nmake[3]: Entering directory '/mnt/c/Users/emoltob/git/redis/deps/jemalloc'\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/jemalloc.sym.o src/jemalloc.c\r\nnm -a src/jemalloc.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/jemalloc.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/arena.sym.o src/arena.c\r\nnm -a src/arena.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/arena.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/background_thread.sym.o src/background_thread.c\r\nnm -a src/background_thread.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/background_thread.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/base.sym.o src/base.c\r\nnm -a src/base.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/base.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/bin.sym.o src/bin.c\r\nnm -a src/bin.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/bin.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/bitmap.sym.o src/bitmap.c\r\nnm -a src/bitmap.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/bitmap.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/ckh.sym.o src/ckh.c\r\nnm -a src/ckh.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/ckh.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/ctl.sym.o src/ctl.c\r\nnm -a src/ctl.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/ctl.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/div.sym.o src/div.c\r\nnm -a src/div.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/div.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/extent.sym.o src/extent.c\r\nnm -a src/extent.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/extent.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/extent_dss.sym.o src/extent_dss.c\r\nnm -a src/extent_dss.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/extent_dss.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/extent_mmap.sym.o src/extent_mmap.c\r\nnm -a src/extent_mmap.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/extent_mmap.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/hash.sym.o src/hash.c\r\nnm -a src/hash.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/hash.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/hooks.sym.o src/hooks.c\r\nnm -a src/hooks.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/hooks.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/large.sym.o src/large.c\r\nnm -a src/large.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/large.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/log.sym.o src/log.c\r\nnm -a src/log.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/log.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/malloc_io.sym.o src/malloc_io.c\r\nnm -a src/malloc_io.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/malloc_io.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/mutex.sym.o src/mutex.c\r\nnm -a src/mutex.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/mutex.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/mutex_pool.sym.o src/mutex_pool.c\r\nnm -a src/mutex_pool.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/mutex_pool.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/nstime.sym.o src/nstime.c\r\nnm -a src/nstime.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/nstime.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/pages.sym.o src/pages.c\r\nnm -a src/pages.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/pages.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/prng.sym.o src/prng.c\r\nnm -a src/prng.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/prng.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/prof.sym.o src/prof.c\r\nnm -a src/prof.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/prof.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/rtree.sym.o src/rtree.c\r\nnm -a src/rtree.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/rtree.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/stats.sym.o src/stats.c\r\nnm -a src/stats.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/stats.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/sz.sym.o src/sz.c\r\nnm -a src/sz.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/sz.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/tcache.sym.o src/tcache.c\r\nnm -a src/tcache.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/tcache.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/ticker.sym.o src/ticker.c\r\nnm -a src/ticker.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/ticker.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/tsd.sym.o src/tsd.c\r\nnm -a src/tsd.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/tsd.sym\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -DJEMALLOC_NO_PRIVATE_NAMESPACE -o src/witness.sym.o src/witness.c\r\nnm -a src/witness.sym.o | gawk -f include/jemalloc/internal/private_symbols.awk > src/witness.sym\r\n/bin/sh include/jemalloc/internal/private_namespace.sh src/jemalloc.sym src/arena.sym src/background_thread.sym src/base.sym src/bin.sym src/bitmap.sym src/ckh.sym src/ctl.sym src/div.sym src/extent.sym src/extent_dss.sym src/extent_mmap.sym src/hash.sym src/hooks.sym src/large.sym src/log.sym src/malloc_io.sym src/mutex.sym src/mutex_pool.sym src/nstime.sym src/pages.sym src/prng.sym src/prof.sym src/rtree.sym src/stats.sym src/sz.sym src/tcache.sym src/ticker.sym src/tsd.sym src/witness.sym > include/jemalloc/internal/private_namespace.gen.h\r\ncp include/jemalloc/internal/private_namespace.gen.h include/jemalloc/internal/private_namespace.gen.h\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc.o src/jemalloc.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/arena.o src/arena.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/background_thread.o src/background_thread.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/base.o src/base.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bin.o\r\nsrc/bin.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bitmap.o src/bitmap.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ckh.o\r\nsrc/ckh.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ctl.o\r\nsrc/ctl.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/div.o\r\nsrc/div.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent.o src/extent.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent_dss.o src/extent_dss.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent_mmap.o src/extent_mmap.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hash.o src/hash.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hooks.o src/hooks.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/large.o src/large.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/log.o\r\nsrc/log.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/malloc_io.o src/malloc_io.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex.o src/mutex.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex_pool.o src/mutex_pool.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/nstime.o src/nstime.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/pages.o src/pages.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prng.o src/prng.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prof.o src/prof.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/rtree.o src/rtree.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/stats.o src/stats.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/sz.o src/sz.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tcache.o src/tcache.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ticker.o src/ticker.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tsd.o\r\nsrc/tsd.c\r\ngcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/witness.o src/witness.c\r\ng++ -Wall -g3 -fvisibility=hidden -O3 -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc_cpp.o src/jemalloc_cpp.cpp\r\nar crus lib/libjemalloc.a src/jemalloc.o src/arena.o src/background_thread.o src/base.o src/bin.o src/bitmap.o src/ckh.o src/ctl.o src/div.o src/extent.o src/extent_dss.o src/extent_mmap.o src/hash.o src/hooks.o src/large.o src/log.o src/malloc_io.o src/mutex.o src/mutex_pool.o src/nstime.o src/pages.o src/prng.o src/prof.o src/rtree.o src/stats.o src/sz.o src/tcache.o src/ticker.o src/tsd.o src/witness.o src/jemalloc_cpp.o\r\nar: `u' modifier ignored since `D' is the default (see `U')\r\nmake[3]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps/jemalloc'\r\nmake[2]: Leaving directory '/mnt/c/Users/emoltob/git/redis/deps'\r\n    CC adlist.o\r\n    CC quicklist.o\r\n    CC ae.o\r\n    CC anet.o\r\n    CC dict.o\r\n    CC server.o\r\n    CC sds.o\r\n    CC zmalloc.o\r\n    CC lzf_c.o\r\n    CC lzf_d.o\r\n    CC pqsort.o\r\n    CC zipmap.o\r\n    CC sha1.o\r\n    CC ziplist.o\r\n    CC release.o\r\n    CC networking.o\r\n    CC util.o\r\n    CC object.o\r\n    CC db.o\r\n    CC replication.o\r\n    CC rdb.o\r\n    CC t_string.o\r\n    CC t_list.o\r\n    CC t_set.o\r\n    CC t_zset.o\r\n    CC t_hash.o\r\n    CC config.o\r\n    CC aof.o\r\n    CC pubsub.o\r\n    CC multi.o\r\n    CC debug.o\r\n    CC sort.o\r\n    CC intset.o\r\n    CC syncio.o\r\n    CC cluster.o\r\n    CC crc16.o\r\n    CC endianconv.o\r\n    CC slowlog.o\r\n    CC scripting.o\r\n    CC bio.o\r\n    CC rio.o\r\n    CC rand.o\r\n    CC memtest.o\r\n    CC crcspeed.o\r\n    CC crc64.o\r\n    CC bitops.o\r\n    CC sentinel.o\r\n    CC notify.o\r\n    CC setproctitle.o\r\n    CC blocked.o\r\n    CC hyperloglog.o\r\n    CC latency.o\r\n    CC sparkline.o\r\n    CC redis-check-rdb.o\r\n    CC redis-check-aof.o\r\n    CC geo.o\r\n    CC lazyfree.o\r\n    CC module.o\r\n    CC evict.o\r\n    CC expire.o\r\n    CC geohash.o\r\n    CC geohash_helper.o\r\n    CC childinfo.o\r\n    CC defrag.o\r\n    CC siphash.o\r\n    CC rax.o\r\n    CC t_stream.o\r\n    CC listpack.o\r\n    CC localtime.o\r\n    CC lolwut.o\r\n    CC lolwut5.o\r\n    CC lolwut6.o\r\n    CC acl.o\r\n    CC gopher.o\r\n    CC tracking.o\r\n    CC connection.o\r\n    CC tls.o\r\n    CC sha256.o\r\n    CC timeout.o\r\n    CC setcpuaffinity.o\r\n    LINK redis-server\r\n    INSTALL redis-check-aof\r\n    CC redis-cli.o\r\n    LINK redis-cli\r\n    CC redis-benchmark.o\r\n    LINK redis-benchmark\r\nCleanup: may take some time... OK\r\nStarting test server at port 11111\r\n[ready]: 6195\r\nTesting unit/printver\r\n[ready]: 6196\r\nTesting unit/dump\r\n[ready]: 6197\r\nTesting unit/auth\r\n[ready]: 6198\r\nTesting unit/protocol\r\n[ready]: 6199\r\nTesting unit/keyspace\r\n[ready]: 6200\r\nTesting unit/scan\r\n[ready]: 6201\r\nTesting unit/type/string\r\n[ready]: 6202\r\nTesting unit/type/incr\r\n[ready]: 6204\r\nTesting unit/type/list\r\n[ready]: 6203\r\nTesting unit/type/list-2\r\n[ready]: 6205\r\nTesting unit/type/list-3\r\n[ready]: 6206\r\nTesting unit/type/set\r\n[ready]: 6207\r\nTesting unit/type/zset\r\n[ready]: 6208\r\nTesting unit/type/hash\r\n[ready]: 6210\r\nTesting unit/type/stream\r\n[ready]: 6209\r\nTesting unit/type/stream-cgroups\r\n[exception]: Executing test client: couldn't fork child process: invalid argument.\r\ncouldn't fork child process: invalid argument\r\n    while executing\r\n\"exec cat $stdout\"\r\n    (procedure \"wait_server_started\" line 6)\r\n    invoked from within\r\n\"wait_server_started $config_file $stdout $pid\"\r\n    (procedure \"start_server\" line 99)\r\n    invoked from within\r\n\"start_server {} {\r\n    set i [r info]\r\n    regexp {redis_version:(.*?)\\r\\n} $i - version\r\n    regexp {redis_git_sha1:(.*?)\\r\\n} $i - sha1\r\n    puts \"Testi...\"\r\n    (file \"tests/unit/printver.tcl\" line 1)\r\n    invoked from within\r\n\"source $path\"\r\n    (procedure \"execute_test_file\" line 4)\r\n    invoked from within\r\n\"execute_test_file $data\"\r\n    (procedure \"test_client_main\" line 10)\r\n    invoked from within\r\n\"test_client_main $::test_server_port \"\r\nKilling still running Redis server 6237\r\nKilling still running Redis server 6238\r\nKilling still running Redis server 6223\r\nKilling still running Redis server 6233\r\nKilling still running Redis server 6242\r\nKilling still running Redis server 6241\r\nKilling still running Redis server 6239\r\nKilling still running Redis server 6235\r\nKilling still running Redis server 6240\r\nKilling still running Redis server 6230\r\nKilling still running Redis server 6226\r\nKilling still running Redis server 6243\r\nKilling still running Redis server 6234\r\nKilling still running Redis server 6232\r\nKilling still running Redis server 6228\r\nKilling still running Redis server 6225\r\nmake[1]: *** [test] Error 1\r\nMakefile:330: recipe for target 'test' failed\r\nmake[1]: Leaving directory '/mnt/c/Users/emoltob/git/redis/src'\r\nmake: *** [test] Error 2\r\nMakefile:6: recipe for target 'test' failed\r\n```\r\n\r\n</details>"
    },
    {
      "id": 681969288,
      "user": "oranagra",
      "created_at": "2020-08-27T14:03:17Z",
      "body": "so it completely fails to execute the test suite (unlike the previous test which failed a specific test). AFAIK nothing major was changed between unstable and 6.0 in that regard."
    },
    {
      "id": 682659540,
      "user": "wolf99",
      "created_at": "2020-08-28T14:54:23Z",
      "body": "Just tried a `make test` again and the PC fell over.\r\nGlimpsed something in the output along the lines of `cgroups` or `egroups` maybe before I held the power button.\r\nAt this point I'm guessing that it is some WSL 1 issue rather than an idiot-at-the-controls issue or a Redis issue.\r\n\r\n(checking available memory in WSL seems fine though  )\r\n<details>\r\n<summary> meminfo </summary>\r\n\r\n```\r\n$ cat /proc/meminfo\r\nMemTotal:       33393880 kB\r\nMemFree:        22831284 kB\r\nBuffers:           34032 kB\r\nCached:           188576 kB\r\nSwapCached:            0 kB\r\nActive:           167556 kB\r\nInactive:         157876 kB\r\nActive(anon):     103104 kB\r\nInactive(anon):    17440 kB\r\nActive(file):      64452 kB\r\nInactive(file):   140436 kB\r\nUnevictable:           0 kB\r\nMlocked:               0 kB\r\nSwapTotal:      62392956 kB\r\nSwapFree:       62392956 kB\r\nDirty:                 0 kB\r\nWriteback:             0 kB\r\nAnonPages:        102824 kB\r\nMapped:            71404 kB\r\nShmem:             17720 kB\r\nSlab:              13868 kB\r\nSReclaimable:       6744 kB\r\nSUnreclaim:         7124 kB\r\nKernelStack:        2848 kB\r\nPageTables:         2524 kB\r\nNFS_Unstable:          0 kB\r\nBounce:                0 kB\r\nWritebackTmp:          0 kB\r\nCommitLimit:      515524 kB\r\nCommitted_AS:    3450064 kB\r\nVmallocTotal:     122880 kB\r\nVmallocUsed:       21296 kB\r\nVmallocChunk:      66044 kB\r\nHardwareCorrupted:     0 kB\r\nAnonHugePages:      2048 kB\r\nHugePages_Total:       0\r\nHugePages_Free:        0\r\nHugePages_Rsvd:        0\r\nHugePages_Surp:        0\r\nHugepagesize:       2048 kB\r\nDirectMap4k:       12280 kB\r\nDirectMap4M:      897024 kB\r\n```\r\n<details>"
    }
  ]
}