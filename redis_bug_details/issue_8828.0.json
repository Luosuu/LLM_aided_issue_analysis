{
  "issue_number": 8828.0,
  "title": "[BUG] `make test` fails on Ubuntu 18.04 (tests/unit/networking.tcl)",
  "body": "**Describe the bug**\r\n\r\n`make test` fails on Ubuntu 18.04 with error:\r\n\r\n```\r\n*** [err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\n```\r\n\r\nI tried to track down the issue and running just the failed test, but the output didn't help me either.\r\n\r\n**To reproduce**\r\n\r\n```\r\nwget http://download.redis.io/redis-stable.tar.gz\r\ntar xvzf redis-stable.tar.gz\r\ncd redis-stable\r\nmake test\r\n\r\n```\r\n\r\n**Expected behavior**\r\n\r\n`make test` does not fail\r\n\r\n**Additional information**\r\n\r\nUsing Ubuntu 18.04. I have some servers where it works, but one server always fails. All servers are set up similarly.\r\n\r\n<details>\r\n<summary>Whole Log Output:</summary>\r\n\r\n```\r\nCleanup: may take some time... OK\r\nStarting test server at port 21079\r\n[ready]: 6295\r\nTesting unit/printver\r\n[ready]: 6294\r\nTesting unit/dump\r\n[ready]: 6297\r\nTesting unit/auth\r\n[ready]: 6296\r\nTesting unit/protocol\r\n[ready]: 6298\r\nTesting unit/keyspace\r\n[ready]: 6299\r\nTesting unit/scan\r\n[ready]: 6301\r\nTesting unit/info\r\n[ready]: 6300\r\nTesting unit/type/string\r\n[ready]: 6302\r\nTesting unit/type/incr\r\n[ready]: 6303\r\nTesting unit/type/list\r\n[ready]: 6305\r\nTesting unit/type/list-2\r\n[ready]: 6307\r\nTesting unit/type/list-3\r\n[ready]: 6304\r\nTesting unit/type/set\r\n[ready]: 6309\r\nTesting unit/type/zset\r\n[ready]: 6306\r\nTesting unit/type/hash\r\n[ready]: 6308\r\nTesting unit/type/stream\r\n[ok]: AUTH fails if there is no password configured server side\r\n[ok]: Explicit regression for a list bug\r\n[ok]: LPOS basic usage\r\n[ok]: LPOS RANK (positive and negative rank) option\r\n[ok]: LPOS COUNT option\r\n[ok]: LPOS COUNT + RANK option\r\n[ok]: LPOS non existing key\r\n[ok]: LPOS no match\r\n[ok]: LPOS MAXLEN\r\n[ok]: LPOS when RANK is greater than matches\r\n[ok]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist\r\n[ok]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list\r\n[ok]: R/LPOP against empty list\r\n[ok]: R/LPOP with the optional count argument\r\n[ok]: Variadic RPUSH/LPUSH\r\n[ok]: DEL a list\r\n[ok]: BLPOP, BRPOP: single existing list - linkedlist\r\n[ok]: BLPOP, BRPOP: multiple existing lists - linkedlist\r\n[ok]: BLPOP, BRPOP: second list has an entry - linkedlist\r\n[ok]: BRPOPLPUSH - linkedlist\r\n[ok]: BLMOVE left left - linkedlist\r\n[ok]: BLMOVE left right - linkedlist\r\n[ok]: BLMOVE right left - linkedlist\r\n[ok]: BLMOVE right right - linkedlist\r\n[ok]: BLPOP, BRPOP: single existing list - ziplist\r\n[ok]: BLPOP, BRPOP: multiple existing lists - ziplist\r\n[ok]: BLPOP, BRPOP: second list has an entry - ziplist\r\n[ok]: BRPOPLPUSH - ziplist\r\n[ok]: BLMOVE left left - ziplist\r\n[ok]: BLMOVE left right - ziplist\r\n[ok]: BLMOVE right left - ziplist\r\n[ok]: BLMOVE right right - ziplist\r\n[ok]: BLPOP, LPUSH + DEL should not awake blocked client\r\n[ok]: DUMP / RESTORE are able to serialize / unserialize a simple key\r\n[ok]: RESTORE can set an arbitrary expire to the materialized key\r\n[ok]: RESTORE can set an expire that overflows a 32 bit integer\r\n[ok]: RESTORE can set an absolute expire\r\n[ok]: RESTORE with ABSTTL in the past\r\n[ok]: RESTORE can set LRU\r\n[ok]: RESTORE can set LFU\r\n[ok]: RESTORE returns an error of the key already exists\r\n[ok]: RESTORE can overwrite an existing key with REPLACE\r\n[ok]: RESTORE can detect a syntax error for unrecongized options\r\n[ok]: DUMP of non existing key returns nil\r\n[ok]: Regression for quicklist #3343 bug\r\n[ok]: HSET/HLEN - Small hash creation\r\n[ok]: DEL against a single item\r\n[ok]: Check encoding - ziplist\r\n[ok]: Vararg DEL\r\n[ok]: Is the small hash encoded with a ziplist?\r\n[ok]: ZSET basic ZADD and score update - ziplist\r\n[ok]: KEYS with pattern\r\n[ok]: KEYS to get all keys\r\n[ok]: ZSET element can't be set to NaN with ZADD - ziplist\r\n[ok]: DBSIZE\r\n[ok]: ZSET element can't be set to NaN with ZINCRBY - ziplist\r\n[ok]: ZADD with options syntax error with incomplete pair - ziplist\r\n[ok]: ZADD XX option without key - ziplist\r\n[ok]: DEL all keys\r\n[ok]: ZADD XX existing key - ziplist\r\n[ok]: ZADD XX returns the number of elements actually added - ziplist\r\n[ok]: ZADD XX updates existing elements score - ziplist\r\n[ok]: ZADD GT updates existing elements when new scores are greater - ziplist\r\n[ok]: SET and GET an item\r\n[ok]: ZADD LT updates existing elements when new scores are lower - ziplist\r\n[ok]: SET and GET an empty item\r\n[ok]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - ziplist\r\n[ok]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - ziplist\r\n[ok]: ZADD XX and NX are not compatible - ziplist\r\nTesting Redis version 6.2.2 (00000000)\r\n[ok]: ZADD NX with non existing key - ziplist\r\n[ok]: ZADD NX only add new elements without updating old ones - ziplist\r\n[ok]: ZADD GT and NX are not compatible - ziplist\r\n[ok]: ZADD LT and NX are not compatible - ziplist\r\n[ok]: ZADD LT and GT are not compatible - ziplist\r\n[ok]: HRANDFIELD - ziplist\r\n[ok]: ZADD INCR LT/GT replies with nill if score not updated - ziplist\r\n[ok]: ZADD INCR LT/GT with inf - ziplist\r\n[ok]: ZADD INCR works like ZINCRBY - ziplist\r\n[ok]: ZADD INCR works with a single score-elemenet pair - ziplist\r\n[ok]: ZADD CH option changes return value to all changed elements - ziplist\r\n[ok]: ZINCRBY calls leading to NaN result in error - ziplist\r\n[ok]: ZADD - Variadic version base case - $encoding\r\n[ok]: ZADD - Return value is the number of actually added items - $encoding\r\n[ok]: ZADD - Variadic version does not add nothing on single parsing err - $encoding\r\n[ok]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - regular set\r\n[ok]: ZADD - Variadic version will raise error on missing arg - $encoding\r\n[ok]: AUTH fails when a wrong password is given\r\n[ok]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding\r\n[ok]: ZCARD basics - ziplist\r\n[ok]: INCR against non existing key\r\n[ok]: Arbitrary command gives an error when AUTH is required\r\n[ok]: AUTH succeeds when the right password is given\r\n[ok]: INCR against key created by incr itself\r\n[ok]: Once AUTH succeeded we can actually send commands to the server\r\n[ok]: ZREM removes key after last element is removed - ziplist\r\n[ok]: INCR against key originally set with SET\r\n[ok]: INCR over 32bit value\r\n[ok]: ZREM variadic version - ziplist\r\n[ok]: ZREM variadic version -- remove elements after key deletion - ziplist\r\n[ok]: INCRBY over 32bit value with over 32bit increment\r\n[ok]: INCR fails against key with spaces (left)\r\n[ok]: SCAN basic\r\n[ok]: INCR fails against key with spaces (right)\r\n[ok]: INCR fails against key with spaces (both)\r\n[ok]: ZRANGE basics - ziplist\r\n[ok]: HRANDFIELD - hashtable\r\n[ok]: INCR fails against a key holding a list\r\n[ok]: DECRBY over 32bit value with over 32bit increment, negative res\r\n[ok]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - intset\r\n[ok]: HRANDFIELD with RESP3\r\n[ok]: SMISMEMBER against non set\r\n[ok]: INCR uses shared objects in the 0-9999 range\r\n[ok]: ZREVRANGE basics - ziplist\r\n[ok]: HRANDFIELD count of 0 is handled correctly\r\n[ok]: SMISMEMBER non existing key\r\n[ok]: INCR can modify objects in-place\r\n[ok]: HRANDFIELD with <count> against non existing key\r\n[ok]: ZRANK/ZREVRANK basics - ziplist\r\n[ok]: ZRANK - after deletion - ziplist\r\n[ok]: INCRBYFLOAT against non existing key\r\n[ok]: ZINCRBY - can create a new sorted set - ziplist\r\n[ok]: INCRBYFLOAT against key originally set with SET\r\n[ok]: INCRBYFLOAT over 32bit value\r\n[ok]: SMISMEMBER requires one or more members\r\n[ok]: ZINCRBY - increment and decrement - ziplist\r\n[ok]: INCRBYFLOAT over 32bit value with over 32bit increment\r\n[ok]: SADD against non set\r\n[ok]: ZINCRBY return value - ziplist\r\n[ok]: INCRBYFLOAT fails against key with spaces (left)\r\n[ok]: INCRBYFLOAT fails against key with spaces (right)\r\n[ok]: INCRBYFLOAT fails against key with spaces (both)\r\n[ok]: INCRBYFLOAT fails against a key holding a list\r\n[ok]: SADD a non-integer against an intset\r\n[ok]: INCRBYFLOAT does not allow NaN or Infinity\r\n[ok]: SADD an integer larger than 64 bits\r\n[ok]: INCRBYFLOAT decrement\r\n[ok]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - ziplist\r\n[ok]: string to double with null terminator\r\n[ok]: ZRANGEBYSCORE with WITHSCORES - ziplist\r\n[ok]: No negative zero\r\n[ok]: ZRANGEBYSCORE with LIMIT - ziplist\r\n[ok]: ZRANGEBYSCORE with LIMIT and WITHSCORES - ziplist\r\n[ok]: ZRANGEBYSCORE with non-value min or max - ziplist\r\n[ok]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - ziplist\r\n[ok]: BLPOP, LPUSH + DEL + SET should not awake blocked client\r\n[ok]: ZLEXCOUNT advanced - ziplist\r\n[ok]: BLPOP with same key multiple times should work (issue #801)\r\n[ok]: ZRANGEBYSLEX with LIMIT - ziplist\r\n[ok]: MULTI/EXEC is isolated from the point of view of BLPOP\r\n[ok]: ZRANGEBYLEX with invalid lex range specifiers - ziplist\r\n[ok]: errorstats: failed call authentication error\r\n[ok]: BLPOP with variadic LPUSH\r\n[ok]: BRPOPLPUSH with zero timeout should block indefinitely\r\n[ok]: errorstats: failed call within MULTI/EXEC\r\n[ok]: BLMOVE left left with zero timeout should block indefinitely\r\n[ok]: BLMOVE left right with zero timeout should block indefinitely\r\n[ok]: errorstats: failed call within LUA\r\n[ok]: BLMOVE right left with zero timeout should block indefinitely\r\n[ok]: BLMOVE right right with zero timeout should block indefinitely\r\n[ok]: errorstats: failed call NOSCRIPT error\r\n[ok]: ZREMRANGEBYSCORE basics - ziplist\r\n[ok]: ZREMRANGEBYSCORE with non-value min or max - ziplist\r\n[ok]: BLMOVE (left, left) with a client BLPOPing the target list\r\n[ok]: errorstats: failed call NOGROUP error\r\n[ok]: BLMOVE (left, right) with a client BLPOPing the target list\r\n[ok]: BLMOVE (right, left) with a client BLPOPing the target list\r\n[ok]: XADD can add entries into a stream that XRANGE can fetch\r\n[ok]: ZREMRANGEBYRANK basics - ziplist\r\n[ok]: XADD IDs are incremental\r\n[ok]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist\r\n[ok]: BLMOVE (right, right) with a client BLPOPing the target list\r\n[ok]: XADD IDs are incremental when ms is the same as well\r\n[ok]: ZUNION/ZINTER/ZDIFF against non-existing key - ziplist\r\n[ok]: errorstats: rejected call unknown command\r\n[ok]: XADD IDs correctly report an error when overflowing\r\n[ok]: BRPOPLPUSH with wrong source type\r\n[ok]: ZUNIONSTORE with empty set - ziplist\r\n[ok]: ZUNION/ZINTER/ZDIFF with empty set - ziplist\r\n[ok]: ZUNIONSTORE basics - ziplist\r\n[ok]: BRPOPLPUSH with wrong destination type\r\n[ok]: errorstats: rejected call within MULTI/EXEC\r\n[ok]: BRPOPLPUSH maintains order of elements after failure\r\n[ok]: ZUNION/ZINTER/ZDIFF with integer members - ziplist\r\n[ok]: ZUNIONSTORE with weights - ziplist\r\n[ok]: SCAN COUNT\r\n[ok]: ZUNION with weights - ziplist\r\n[ok]: errorstats: rejected call due to wrong arity\r\n[ok]: Handle an empty query\r\n[ok]: BRPOPLPUSH with multiple blocked clients\r\n[ok]: ZUNIONSTORE with a regular set and weights - ziplist\r\n[ok]: ZUNIONSTORE with AGGREGATE MIN - ziplist\r\n[ok]: ZUNION/ZINTER with AGGREGATE MIN - ziplist\r\n[ok]: ZUNIONSTORE with AGGREGATE MAX - ziplist\r\n[ok]: errorstats: rejected call by OOM error\r\n[ok]: ZUNION/ZINTER with AGGREGATE MAX - ziplist\r\n[ok]: ZINTERSTORE basics - ziplist\r\n[ok]: ZINTER basics - ziplist\r\n[ok]: Linked LMOVEs\r\n[ok]: ZINTER RESP3 - ziplist\r\n[ok]: ZINTERSTORE with weights - ziplist\r\n[ok]: ZINTER with weights - ziplist\r\n[ok]: errorstats: rejected call by authorization error\r\n[ok]: ZINTERSTORE with a regular set and weights - ziplist\r\n[ok]: ZINTERSTORE with AGGREGATE MIN - ziplist\r\n[ok]: ZINTERSTORE with AGGREGATE MAX - ziplist\r\n[ok]: ZUNIONSTORE with +inf/-inf scores - ziplist\r\n[ok]: ZUNIONSTORE with NaN weights - ziplist\r\n[ok]: ZINTERSTORE with +inf/-inf scores - ziplist\r\n[ok]: ZINTERSTORE with NaN weights - ziplist\r\n[ok]: ZDIFFSTORE basics - ziplist\r\n[ok]: ZDIFF basics - ziplist\r\n[ok]: ZDIFFSTORE with a regular set - ziplist\r\n[ok]: ZDIFF subtracting set from itself - ziplist\r\n[ok]: ZDIFF algorithm 1 - ziplist\r\n[ok]: ZDIFF algorithm 2 - ziplist\r\n[ok]: Circular BRPOPLPUSH\r\n[ok]: Self-referential BRPOPLPUSH\r\n[ok]: SCAN MATCH\r\n[ok]: BRPOPLPUSH inside a transaction\r\n[ok]: PUSH resulting from BRPOPLPUSH affect WATCH\r\n[ok]: BRPOPLPUSH does not affect WATCH while still blocked\r\n[ok]: SADD overflows the maximum allowed integers in an intset\r\n[ok]: Variadic SADD\r\n[ok]: SCAN TYPE\r\n[ok]: SSCAN with encoding intset\r\n[ok]: Negative multibulk length\r\n[ok]: Out of range multibulk length\r\n[ok]: Wrong multibulk payload header\r\n[ok]: Negative multibulk payload length\r\n[ok]: Out of range multibulk payload length\r\n[ok]: Non-number multibulk payload length\r\n[ok]: Multi bulk request not followed by bulk arguments\r\n[ok]: Generic wrong number of args\r\n[ok]: Unbalanced number of quotes\r\n[ok]: Very big payload in GET/SET\r\n[ok]: SSCAN with encoding hashtable\r\n[ok]: HSCAN with encoding ziplist\r\n[ok]: XADD with MAXLEN option\r\n[1/64 done]: unit/printver (1 seconds)\r\nTesting unit/type/stream-cgroups\r\n[2/64 done]: unit/type/incr (1 seconds)\r\nTesting unit/sort\r\n[ok]: Set encoding after DEBUG RELOAD\r\n[ok]: Protocol desync regression test #1\r\n[ok]: SREM basics - regular set\r\n[ok]: SREM basics - intset\r\n[ok]: SREM with multiple arguments\r\n[ok]: SREM variadic version with more args needed to destroy the key\r\n[ok]: AUTH fails when binary password is wrong\r\n[ok]: AUTH succeeds when binary password is correct\r\n[ok]: HRANDFIELD with <count> - hashtable\r\n[ok]: XADD with MAXLEN option and the '=' argument\r\n[ok]: XGROUP CREATE: creation and duplicate group name detection\r\n[ok]: XGROUP CREATE: automatic stream creation fails without MKSTREAM\r\n[ok]: XGROUP CREATE: automatic stream creation works with MKSTREAM\r\n[ok]: MIGRATE is caching connections\r\n[ok]: XREADGROUP will return only new elements\r\n[ok]: XREADGROUP can read the history of the elements we own\r\n[ok]: XPENDING is able to return pending items\r\n[ok]: XPENDING can return single consumer items\r\n[ok]: XPENDING only group\r\n[ok]: Generated sets must be encoded as hashtable\r\n[ok]: SINTER with two sets - hashtable\r\n[ok]: SINTERSTORE with two sets - hashtable\r\n[ok]: XPENDING with IDLE\r\n[ok]: XPENDING with exclusive range intervals works as expected\r\n[ok]: XACK is able to remove items from the consumer/group PEL\r\n[ok]: XACK can't remove the same item multiple times\r\n[ok]: XACK is able to accept multiple arguments\r\n[ok]: XACK should fail if got at least one invalid ID\r\n[ok]: PEL NACK reassignment after XGROUP SETID event\r\n[ok]: XREADGROUP will not report data on empty history. Bug #5577\r\n[ok]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable\r\n[ok]: XREADGROUP history reporting of deleted entries. Bug #5570\r\n[ok]: Protocol desync regression test #2\r\n[ok]: HSCAN with encoding hashtable\r\n[ok]: SUNION with two sets - hashtable\r\n[ok]: ZSCAN with encoding ziplist\r\n[ok]: SUNIONSTORE with two sets - hashtable\r\n[ok]: SINTER against three sets - hashtable\r\n[ok]: SINTERSTORE with three sets - hashtable\r\n[ok]: SUNION with non existing keys - hashtable\r\n[ok]: SDIFF with two sets - hashtable\r\n[ok]: SDIFF with three sets - hashtable\r\n[ok]: SDIFFSTORE with three sets - hashtable\r\n[ok]: Old Ziplist: SORT BY key\r\n[ok]: Old Ziplist: SORT BY key with limit\r\n[ok]: Unsafe command names are sanitized in INFO output\r\n[ok]: Old Ziplist: SORT BY hash field\r\n[ok]: XADD with MAXLEN option and the '~' argument\r\n[ok]: XADD with NOMKSTREAM option\r\n[ok]: HRANDFIELD with <count> - ziplist\r\n[ok]: Blocking XREADGROUP will not reply with an empty array\r\n[ok]: XGROUP DESTROY should unblock XREADGROUP with -NOGROUP\r\n[ok]: RENAME can unblock XREADGROUP with data\r\n[ok]: Protocol desync regression test #3\r\n[ok]: RENAME can unblock XREADGROUP with -NOGROUP\r\n[ok]: Generated sets must be encoded as intset\r\n[ok]: SINTER with two sets - intset\r\n[ok]: SINTERSTORE with two sets - intset\r\n[ok]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset\r\n[ok]: SUNION with two sets - intset\r\n[ok]: SUNIONSTORE with two sets - intset\r\n[ok]: SINTER against three sets - intset\r\n[ok]: SINTERSTORE with three sets - intset\r\n[ok]: SUNION with non existing keys - intset\r\n[ok]: SDIFF with two sets - intset\r\n[ok]: SDIFF with three sets - intset\r\n[ok]: SDIFFSTORE with three sets - intset\r\n[ok]: SDIFF with first set empty\r\n[ok]: SDIFF with same set two times\r\n[ok]: ZSCAN with encoding skiplist\r\n[ok]: SCAN guarantees check under write load\r\n[ok]: SSCAN with integer encoded object (issue #1345)\r\n[ok]: SSCAN with PATTERN\r\n[ok]: HSCAN with PATTERN\r\n[ok]: ZSCAN with PATTERN\r\n[ok]: XADD with MINID option\r\n[ok]: XTRIM with MINID option\r\n[ok]: HSET/HLEN - Big hash creation\r\n[ok]: Is the big hash encoded with an hash table?\r\n[ok]: HGET against the small hash\r\n[ok]: Regression for a crash with blocking ops and pipelining\r\n[ok]: ZSCAN scores: regression test for issue #2175\r\n[ok]: HGET against the big hash\r\n[ok]: HGET against non existing key\r\n[ok]: HSET in update and insert mode\r\n[ok]: HSETNX target key missing - small hash\r\n[ok]: HSETNX target key exists - small hash\r\n[ok]: HSETNX target key missing - big hash\r\n[ok]: HSETNX target key exists - big hash\r\n[ok]: HMSET wrong number of args\r\n[ok]: HMSET - small hash\r\n[3/64 done]: unit/info (1 seconds)\r\nTesting unit/expire\r\n[ok]: Old Linked list: SORT BY key\r\n[ok]: Old Linked list: SORT BY key with limit\r\n[ok]: HMSET - big hash\r\n[ok]: HMGET against non existing key and fields\r\n[ok]: HMGET against wrong type\r\n[ok]: HMGET - small hash\r\n[ok]: Old Linked list: SORT BY hash field\r\n[4/64 done]: unit/protocol (1 seconds)\r\nTesting unit/other\r\n[ok]: EXPIRE - set timeouts multiple times\r\n[ok]: EXPIRE - It should be still possible to read 'x'\r\n[ok]: HMGET - big hash\r\n[ok]: HKEYS - small hash\r\n[ok]: HKEYS - big hash\r\n[ok]: HVALS - small hash\r\n[ok]: HVALS - big hash\r\n[ok]: HGETALL - small hash\r\n[ok]: HGETALL - big hash\r\n[ok]: HDEL and return value\r\n[ok]: HDEL - more than a single value\r\n[ok]: HDEL - hash becomes empty before deleting all specified fields\r\n[ok]: HEXISTS\r\n[ok]: Is a ziplist encoded Hash promoted on big payload?\r\n[ok]: HINCRBY against non existing database key\r\n[ok]: HINCRBY against non existing hash key\r\n[ok]: HINCRBY against hash key created by hincrby itself\r\n[ok]: HINCRBY against hash key originally set with HSET\r\n[ok]: HINCRBY over 32bit value\r\n[ok]: HINCRBY over 32bit value with over 32bit increment\r\n[ok]: HINCRBY fails against hash value with spaces (left)\r\n[ok]: HINCRBY fails against hash value with spaces (right)\r\n[ok]: HINCRBY can detect overflows\r\n[ok]: HINCRBYFLOAT against non existing database key\r\n[ok]: HINCRBYFLOAT against non existing hash key\r\n[ok]: HINCRBYFLOAT against hash key created by hincrby itself\r\n[ok]: HINCRBYFLOAT against hash key originally set with HSET\r\n[ok]: HINCRBYFLOAT over 32bit value\r\n[ok]: HINCRBYFLOAT over 32bit value with over 32bit increment\r\n[ok]: HINCRBYFLOAT fails against hash value with spaces (left)\r\n[ok]: HINCRBYFLOAT fails against hash value with spaces (right)\r\n[ok]: HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle\r\n[ok]: HSTRLEN against the small hash\r\n[ok]: HSTRLEN against the big hash\r\n[ok]: HSTRLEN against non existing field\r\n[ok]: HSTRLEN corner cases\r\n[ok]: Hash ziplist regression test for large keys\r\n[ok]: SAVE - make sure there are all the types as values\r\n[ok]: Hash fuzzing #1 - 10 fields\r\n[ok]: Hash fuzzing #2 - 10 fields\r\n[ok]: XCLAIM can claim PEL items from another consumer\r\n[ok]: FUZZ stresser with data model binary\r\n[ok]: BRPOPLPUSH timeout\r\n[ok]: BLPOP when new key is moved into place\r\n[ok]: BLPOP when result key is created by SORT..STORE\r\n[ok]: BLPOP: with single empty list argument\r\n[ok]: BLPOP: with negative timeout\r\n[ok]: DEL against expired key\r\n[ok]: EXISTS\r\n[ok]: Zero length value in key. SET/GET/EXISTS\r\n[ok]: Commands pipelining\r\n[ok]: Non existing command\r\n[ok]: RENAME basic usage\r\n[ok]: RENAME source key should no longer exist\r\n[ok]: RENAME against already existing key\r\n[ok]: RENAMENX basic usage\r\n[ok]: RENAMENX against already existing key\r\n[ok]: RENAMENX against already existing key (2)\r\n[ok]: RENAME against non existing source key\r\n[ok]: RENAME where source and dest key are the same (existing)\r\n[ok]: RENAMENX where source and dest key are the same (existing)\r\n[ok]: RENAME where source and dest key are the same (non existing)\r\n[ok]: RENAME with volatile key, should move the TTL as well\r\n[ok]: RENAME with volatile key, should not inherit TTL of target key\r\n[ok]: DEL all keys again (DB 0)\r\n[ok]: DEL all keys again (DB 1)\r\n[ok]: COPY basic usage for string\r\n[ok]: COPY for string does not replace an existing key without REPLACE option\r\n[ok]: COPY for string can replace an existing key with REPLACE option\r\n[ok]: COPY for string ensures that copied data is independent of copying data\r\n[ok]: COPY for string does not copy data to no-integer DB\r\n[ok]: COPY can copy key expire metadata as well\r\n[ok]: COPY does not create an expire if it does not exist\r\n[ok]: COPY basic usage for list\r\n[ok]: COPY basic usage for intset set\r\n[ok]: COPY basic usage for hashtable set\r\n[ok]: COPY basic usage for ziplist sorted set\r\n[ok]: COPY basic usage for skiplist sorted set\r\n[ok]: COPY basic usage for ziplist hash\r\n[ok]: COPY basic usage for hashtable hash\r\n[ok]: COPY basic usage for stream\r\n[ok]: COPY basic usage for stream-cgroups\r\n[ok]: MOVE basic usage\r\n[ok]: MOVE against key existing in the target DB\r\n[ok]: MOVE against non-integer DB (#1428)\r\n[ok]: MOVE can move key expire metadata as well\r\n[ok]: MOVE does not create an expire if it does not exist\r\n[ok]: SET/GET keys in different DBs\r\n[ok]: RANDOMKEY\r\n[ok]: RANDOMKEY against empty DB\r\n[ok]: RANDOMKEY regression 1\r\n[ok]: KEYS * two times with long key, Github issue #1208\r\n[ok]: XCLAIM without JUSTID increments delivery count\r\n[5/64 done]: unit/keyspace (2 seconds)\r\nTesting unit/multi\r\n[ok]: MASTERAUTH test with binary password\r\n[ok]: MUTLI / EXEC basics\r\n[ok]: DISCARD\r\n[ok]: Nested MULTI are not allowed\r\n[ok]: MULTI where commands alter argc/argv\r\n[ok]: WATCH inside MULTI is not allowed\r\n[ok]: EXEC fails if there are errors while queueing commands #1\r\n[ok]: EXEC fails if there are errors while queueing commands #2\r\n[ok]: If EXEC aborts, the client MULTI state is cleared\r\n[ok]: EXEC works on WATCHed key not modified\r\n[ok]: EXEC fail on WATCHed key modified (1 key of 1 watched)\r\n[ok]: EXEC fail on WATCHed key modified (1 key of 5 watched)\r\n[ok]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty\r\n[ok]: After successful EXEC key is no longer watched\r\n[ok]: After failed EXEC key is no longer watched\r\n[ok]: It is possible to UNWATCH\r\n[ok]: UNWATCH when there is nothing watched works as expected\r\n[ok]: FLUSHALL is able to touch the watched keys\r\n[ok]: FLUSHALL does not touch non affected keys\r\n[ok]: FLUSHDB is able to touch the watched keys\r\n[ok]: FLUSHDB does not touch non affected keys\r\n[ok]: SWAPDB is able to touch the watched keys that exist\r\n[ok]: SWAPDB is able to touch the watched keys that do not exist\r\n[ok]: WATCH is able to remember the DB a key belongs to\r\n[ok]: WATCH will consider touched keys target of EXPIRE\r\n[ok]: BLPOP: with non-integer timeout\r\n[ok]: XCLAIM same consumer\r\n[6/64 done]: unit/auth (2 seconds)\r\nTesting unit/quit\r\n[ok]: QUIT returns OK\r\n[ok]: Pipelined commands after QUIT must not be executed\r\n[ok]: Pipelined commands after QUIT that exceed read buffer size\r\n[ok]: FUZZ stresser with data model alpha\r\n[7/64 done]: unit/quit (0 seconds)\r\nTesting unit/aofrw\r\n[ok]: Hash fuzzing #1 - 512 fields\r\n[ok]: XAUTOCLAIM can claim PEL items from another consumer\r\n[ok]: FUZZ stresser with data model compr\r\n[ok]: XAUTOCLAIM as an iterator\r\n[ok]: XAUTOCLAIM COUNT must be > 0\r\n[ok]: XINFO FULL output\r\n[ok]: XGROUP CREATECONSUMER: create consumer if does not exist\r\n[ok]: XGROUP CREATECONSUMER: group must exist\r\n[ok]: BLPOP: with zero timeout should block indefinitely\r\n[ok]: BLPOP: second argument is not a list\r\n[ok]: XREADGROUP with NOACK creates consumer\r\n[ok]: WATCH will consider touched expired keys\r\n[ok]: DISCARD should clear the WATCH dirty flag on the client\r\n[ok]: DISCARD should UNWATCH all the keys\r\n[ok]: XADD mass insertion and XLEN\r\n[ok]: XADD with ID 0-0\r\n[ok]: XRANGE COUNT works as expected\r\n[ok]: XREVRANGE COUNT works as expected\r\n[ok]: Very big payload random access\r\n[ok]: EXPIRE - After 2.1 seconds the key should no longer be here\r\n[ok]: EXPIRE - write on expire should work\r\n[ok]: EXPIREAT - Check for EXPIRE alike behavior\r\n[ok]: SETEX - Set + Expire combo operation. Check for TTL\r\n[ok]: SETEX - Check value\r\n[ok]: SETEX - Overwrite old key\r\n[ok]: MULTI / EXEC is propagated correctly (single write command)\r\n[ok]: Old Big Linked list: SORT BY key\r\n[ok]: Old Big Linked list: SORT BY key with limit\r\n[ok]: MULTI / EXEC is propagated correctly (empty transaction)\r\n[ok]: MULTI / EXEC is propagated correctly (read-only commands)\r\n[ok]: MULTI / EXEC is propagated correctly (write command, no effect)\r\n[ok]: DISCARD should not fail during OOM\r\n[ok]: Old Big Linked list: SORT BY hash field\r\n[ok]: Intset: SORT BY key\r\n[ok]: Intset: SORT BY key with limit\r\n[ok]: Intset: SORT BY hash field\r\n[ok]: Hash fuzzing #2 - 512 fields\r\n[ok]: XRANGE can be used to iterate the whole stream\r\n[ok]: BGSAVE\r\n[ok]: SELECT an out of range DB\r\n[ok]: Hash table: SORT BY key\r\n[ok]: Hash table: SORT BY key with limit\r\n[ok]: Hash table: SORT BY hash field\r\n[ok]: MULTI and script timeout\r\n[ok]: SDIFF fuzzing\r\n[ok]: SINTER against non-set should throw error\r\n[ok]: SUNION against non-set should throw error\r\n[ok]: SINTER should handle non existing key as empty\r\n[ok]: SINTER with same integer elements but different encoding\r\n[ok]: SINTERSTORE against non existing keys should delete dstkey\r\n[ok]: SUNIONSTORE against non existing keys should delete dstkey\r\n[ok]: SPOP basics - hashtable\r\n[ok]: SPOP with <count>=1 - hashtable\r\n[ok]: SRANDMEMBER - hashtable\r\n[ok]: SPOP basics - intset\r\n[ok]: SPOP with <count>=1 - intset\r\n[ok]: SRANDMEMBER - intset\r\n[ok]: SPOP with <count>\r\n[ok]: SPOP with <count>\r\n[ok]: SPOP using integers, testing Knuth's and Floyd's algorithm\r\n[ok]: SPOP using integers with Knuth's algorithm\r\n[ok]: SPOP new implementation: code path #1\r\n[ok]: SPOP new implementation: code path #2\r\n[ok]: SPOP new implementation: code path #3\r\n[ok]: SRANDMEMBER with <count> against non existing key\r\n[ok]: SRANDMEMBER with <count> - hashtable\r\n[ok]: SRANDMEMBER with <count> - intset\r\n[ok]: SRANDMEMBER histogram distribution - hashtable\r\n[ok]: ZDIFF fuzzing - ziplist\r\n[ok]: Basic ZPOP with a single key - ziplist\r\n[ok]: ZPOP with count - ziplist\r\n[ok]: BZPOP with a single existing sorted set - ziplist\r\n[ok]: BZPOP with multiple existing sorted sets - ziplist\r\n[ok]: BZPOP second sorted set has members - ziplist\r\n[ok]: Check encoding - skiplist\r\n[ok]: ZSET basic ZADD and score update - skiplist\r\n[ok]: ZSET element can't be set to NaN with ZADD - skiplist\r\n[ok]: ZSET element can't be set to NaN with ZINCRBY - skiplist\r\n[ok]: ZADD with options syntax error with incomplete pair - skiplist\r\n[ok]: ZADD XX option without key - skiplist\r\n[ok]: ZADD XX existing key - skiplist\r\n[ok]: ZADD XX returns the number of elements actually added - skiplist\r\n[ok]: ZADD XX updates existing elements score - skiplist\r\n[ok]: ZADD GT updates existing elements when new scores are greater - skiplist\r\n[ok]: ZADD LT updates existing elements when new scores are lower - skiplist\r\n[ok]: BLPOP: timeout\r\n[ok]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - skiplist\r\n[ok]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - skiplist\r\n[ok]: ZADD XX and NX are not compatible - skiplist\r\n[ok]: ZADD NX with non existing key - skiplist\r\n[ok]: ZADD NX only add new elements without updating old ones - skiplist\r\n[ok]: ZADD GT and NX are not compatible - skiplist\r\n[ok]: BLPOP: arguments are empty\r\n[ok]: ZADD LT and NX are not compatible - skiplist\r\n[ok]: ZADD LT and GT are not compatible - skiplist\r\n[ok]: ZADD INCR LT/GT replies with nill if score not updated - skiplist\r\n[ok]: BRPOP: with single empty list argument\r\n[ok]: BRPOP: with negative timeout\r\n[ok]: ZADD INCR LT/GT with inf - skiplist\r\n[ok]: ZADD INCR works like ZINCRBY - skiplist\r\n[ok]: BRPOP: with non-integer timeout\r\n[ok]: ZADD INCR works with a single score-elemenet pair - skiplist\r\n[ok]: ZADD CH option changes return value to all changed elements - skiplist\r\n[ok]: ZINCRBY calls leading to NaN result in error - skiplist\r\n[ok]: ZADD - Variadic version base case - $encoding\r\n[ok]: ZADD - Return value is the number of actually added items - $encoding\r\n[ok]: ZADD - Variadic version does not add nothing on single parsing err - $encoding\r\n[ok]: ZADD - Variadic version will raise error on missing arg - $encoding\r\n[ok]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding\r\n[ok]: ZCARD basics - skiplist\r\n[ok]: ZREM removes key after last element is removed - skiplist\r\n[ok]: ZREM variadic version - skiplist\r\n[ok]: ZREM variadic version -- remove elements after key deletion - skiplist\r\n[ok]: ZRANGE basics - skiplist\r\n[ok]: ZREVRANGE basics - skiplist\r\n[ok]: ZRANK/ZREVRANK basics - skiplist\r\n[ok]: ZRANK - after deletion - skiplist\r\n[ok]: ZINCRBY - can create a new sorted set - skiplist\r\n[ok]: ZINCRBY - increment and decrement - skiplist\r\n[ok]: ZINCRBY return value - skiplist\r\n[ok]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - skiplist\r\n[ok]: ZRANGEBYSCORE with WITHSCORES - skiplist\r\n[ok]: ZRANGEBYSCORE with LIMIT - skiplist\r\n[ok]: ZRANGEBYSCORE with LIMIT and WITHSCORES - skiplist\r\n[ok]: ZRANGEBYSCORE with non-value min or max - skiplist\r\n[ok]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - skiplist\r\n[ok]: ZLEXCOUNT advanced - skiplist\r\n[ok]: ZRANGEBYSLEX with LIMIT - skiplist\r\n[ok]: ZRANGEBYLEX with invalid lex range specifiers - skiplist\r\n[ok]: ZREMRANGEBYSCORE basics - skiplist\r\n[ok]: ZREMRANGEBYSCORE with non-value min or max - skiplist\r\n[ok]: ZREMRANGEBYRANK basics - skiplist\r\n[ok]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist\r\n[ok]: ZUNION/ZINTER/ZDIFF against non-existing key - skiplist\r\n[ok]: ZUNIONSTORE with empty set - skiplist\r\n[ok]: ZUNION/ZINTER/ZDIFF with empty set - skiplist\r\n[ok]: ZUNIONSTORE basics - skiplist\r\n[ok]: ZUNION/ZINTER/ZDIFF with integer members - skiplist\r\n[ok]: ZUNIONSTORE with weights - skiplist\r\n[ok]: ZUNION with weights - skiplist\r\n[ok]: ZUNIONSTORE with a regular set and weights - skiplist\r\n[ok]: ZUNIONSTORE with AGGREGATE MIN - skiplist\r\n[ok]: ZUNION/ZINTER with AGGREGATE MIN - skiplist\r\n[ok]: SRANDMEMBER histogram distribution - intset\r\n[ok]: ZUNIONSTORE with AGGREGATE MAX - skiplist\r\n[ok]: Consumer without PEL is present in AOF after AOFRW\r\n[ok]: ZUNION/ZINTER with AGGREGATE MAX - skiplist\r\n[ok]: ZINTERSTORE basics - skiplist\r\n[ok]: ZINTER basics - skiplist\r\n[ok]: SMOVE basics - from regular set to intset\r\n[ok]: ZINTER RESP3 - skiplist\r\n[ok]: ZINTERSTORE with weights - skiplist\r\n[ok]: SMOVE basics - from intset to regular set\r\n[ok]: ZINTER with weights - skiplist\r\n[ok]: ZINTERSTORE with a regular set and weights - skiplist\r\n[ok]: SMOVE non existing key\r\n[ok]: ZINTERSTORE with AGGREGATE MIN - skiplist\r\n[ok]: ZINTERSTORE with AGGREGATE MAX - skiplist\r\n[ok]: SMOVE non existing src set\r\n[ok]: SMOVE from regular set to non existing destination set\r\n[ok]: ZUNIONSTORE with +inf/-inf scores - skiplist\r\n[ok]: ZUNIONSTORE with NaN weights - skiplist\r\n[ok]: SMOVE from intset to non existing destination set\r\n[ok]: SMOVE wrong src key type\r\n[ok]: SMOVE wrong dst key type\r\n[ok]: SMOVE with identical source and destination\r\n[ok]: ZINTERSTORE with +inf/-inf scores - skiplist\r\n[ok]: ZINTERSTORE with NaN weights - skiplist\r\n[ok]: ZDIFFSTORE basics - skiplist\r\n[ok]: ZDIFF basics - skiplist\r\n[ok]: ZDIFFSTORE with a regular set - skiplist\r\n[ok]: ZDIFF subtracting set from itself - skiplist\r\n[ok]: ZDIFF algorithm 1 - skiplist\r\n[ok]: ZDIFF algorithm 2 - skiplist\r\n[ok]: Check consistency of different data types after a reload\r\n[ok]: SETEX - Wait for the key to expire\r\n[ok]: SETEX - Wrong time parameter\r\n[ok]: PERSIST can undo an EXPIRE\r\n[ok]: PERSIST returns 0 against non existing or non volatile keys\r\n[ok]: EXEC and script timeout\r\n[ok]: Consumer group last ID propagation to slave (NOACK=0)\r\n[ok]: Consumer group last ID propagation to slave (NOACK=1)\r\n[ok]: SET 10000 numeric keys and access all them in reverse order\r\n[ok]: DBSIZE should be 10000 now\r\n[ok]: SETNX target key missing\r\n[ok]: SETNX target key exists\r\n[ok]: SETNX against not-expired volatile key\r\n[ok]: MULTI-EXEC body and script timeout\r\n[ok]: BRPOP: with zero timeout should block indefinitely\r\n[ok]: BRPOP: second argument is not a list\r\n[ok]: just EXEC and script timeout\r\n[ok]: exec with write commands and state change\r\n[ok]: exec with read commands and stale replica state change\r\n[ok]: EXEC with only read commands should not be rejected when OOM\r\n[ok]: EXEC with at least one use-memory command should fail\r\n[ok]: Blocking commands ignores the timeout\r\n[ok]: MULTI propagation of PUBLISH\r\n[ok]: Same dataset digest if saving/reloading as AOF?\r\n[ok]: Stress test the hash ziplist -> hashtable encoding conversion\r\n[ok]: Test HINCRBYFLOAT for correct float representation (issue #2846)\r\n[ok]: XREVRANGE returns the reverse of XRANGE\r\n[ok]: XRANGE exclusive ranges\r\n[ok]: XREAD with non empty stream\r\n[ok]: Non blocking XREAD with empty streams\r\n[ok]: XREAD with non empty second stream\r\n[ok]: Blocking XREAD waiting new data\r\n[ok]: Blocking XREAD waiting old data\r\n[ok]: MULTI propagation of SCRIPT LOAD\r\n[ok]: Hash ziplist of various encodings\r\n[ok]: Hash ziplist of various encodings - sanitize dump\r\n[ok]: Blocking XREAD will not reply with an empty array\r\n[ok]: XREAD: XADD + DEL should not awake client\r\n[ok]: XREAD: XADD + DEL + LPUSH should not awake client\r\n[ok]: XREAD with same stream name multiple times should work\r\n[ok]: XREAD + multiple XADD inside transaction\r\n[ok]: XDEL basic test\r\n[ok]: MULTI propagation of SCRIPT LOAD\r\n[8/64 done]: unit/type/hash (5 seconds)\r\nTesting unit/acl\r\n[ok]: MULTI propagation of XREADGROUP\r\n[ok]: Connections start with the default user\r\n[ok]: It is possible to create new users\r\n[ok]: New users start disabled\r\n[ok]: Enabling the user allows the login\r\n[ok]: Only the set of correct passwords work\r\n[ok]: It is possible to remove passwords from the set of valid ones\r\n[ok]: Test password hashes can be added\r\n[ok]: Test password hashes validate input\r\n[ok]: ACL GETUSER returns the password hash instead of the actual password\r\n[ok]: Test hashed passwords removal\r\n[ok]: By default users are not able to access any command\r\n[ok]: By default users are not able to access any key\r\n[ok]: It's possible to allow the access of a subset of keys\r\n[ok]: By default users are able to publish to any channel\r\n[ok]: By default users are able to subscribe to any channel\r\n[ok]: By default users are able to subscribe to any pattern\r\n[ok]: It's possible to allow publishing to a subset of channels\r\n[ok]: Validate subset of channels is prefixed with resetchannels flag\r\n[ok]: In transaction queue publish/subscribe/psubscribe to unauthorized channel will fail\r\n[ok]: It's possible to allow subscribing to a subset of channels\r\n[ok]: It's possible to allow subscribing to a subset of channel patterns\r\n[ok]: Subscribers are killed when revoked of channel permission\r\n[ok]: Subscribers are killed when revoked of pattern permission\r\n[ok]: Subscribers are pardoned if literal permissions are retained and/or gaining allchannels\r\n[ok]: Users can be configured to authenticate with any password\r\n[ok]: ACLs can exclude single commands\r\n[ok]: ACLs can include or exclude whole classes of commands\r\n[ok]: ACLs can include single subcommands\r\n[ok]: intsets implementation stress testing\r\n[ok]: ACLs set can include subcommands, if already full command exists\r\n[ok]: ACL GETUSER is able to translate back command permissions\r\n[ok]: ACL GETUSER provides reasonable results\r\n[ok]: ACL #5998 regression: memory leaks adding / removing subcommands\r\n[ok]: ACL LOG shows failed command executions at toplevel\r\n[ok]: ACL LOG is able to test similar events\r\n[ok]: ACL LOG is able to log keys access violations and key name\r\n[ok]: ACL LOG is able to log channel access violations and channel name\r\n[ok]: ACL LOG RESET is able to flush the entries in the log\r\n[ok]: ACL LOG can distinguish the transaction context (1)\r\n[ok]: ACL LOG can distinguish the transaction context (2)\r\n[ok]: ACL can log errors in the context of Lua scripting\r\n[ok]: ACL LOG can accept a numerical argument to show less entries\r\n[ok]: ACL LOG can log failed auth attempts\r\n[ok]: ACL LOG entries are limited to a maximum amount\r\n[ok]: When default user is off, new connections are not authenticated\r\n[ok]: When default user has no command permission, hello command still works for other users\r\n[ok]: ACL HELP should not have unexpected options\r\n[ok]: Delete a user that the client doesn't use\r\n[ok]: Delete a user that the client is using\r\n[9/64 done]: unit/multi (4 seconds)\r\nTesting unit/latency-monitor\r\n[10/64 done]: unit/type/set (6 seconds)\r\nTesting integration/block-repl\r\n[ok]: Empty stream with no lastid can be rewrite into AOF correctly\r\n[ok]: default: load from include file, can access any channels\r\n[ok]: default: with config acl-pubsub-default allchannels after reset, can access any channels\r\n[ok]: default: with config acl-pubsub-default resetchannels after reset, can not access any channels\r\n[ok]: Alice: can execute all command\r\n[ok]: Bob: just execute @set and acl command\r\n[ok]: ACL load and save\r\n[ok]: ACL load and save with restricted channels\r\n[11/64 done]: unit/type/stream-cgroups (5 seconds)\r\nTesting integration/replication\r\n[ok]: Big Hash table: SORT BY key\r\n[ok]: Big Hash table: SORT BY key with limit\r\n[ok]: Default user has access to all channels irrespective of flag\r\n[ok]: Update acl-pubsub-default, existing users shouldn't get affected\r\n[ok]: Single channel is valid\r\n[ok]: Single channel is not valid with allchannels\r\n[ok]: Slave enters handshake\r\n[ok]: BRPOP: timeout\r\n[ok]: BRPOP: arguments are empty\r\n[ok]: BLPOP inside a transaction\r\n[ok]: LPUSHX, RPUSHX - generic\r\n[ok]: LPUSHX, RPUSHX - linkedlist\r\n[ok]: LINSERT - linkedlist\r\n[ok]: LPUSHX, RPUSHX - ziplist\r\n[ok]: LINSERT - ziplist\r\n[ok]: LINSERT raise error on bad syntax\r\n[ok]: LINDEX consistency test - quicklist\r\n[ok]: LINDEX random access - quicklist\r\n[ok]: EXPIRES after a reload (snapshot + append only file rewrite)\r\n[ok]: Big Hash table: SORT BY hash field\r\n[ok]: SORT GET #\r\n[ok]: SORT GET <const>\r\n[ok]: SORT GET (key and hash) with sanity check\r\n[ok]: SORT BY key STORE\r\n[ok]: SORT BY hash field STORE\r\n[ok]: SORT extracts STORE correctly\r\n[ok]: SORT extracts multiple STORE correctly\r\n[ok]: SORT DESC\r\n[ok]: SORT ALPHA against integer encoded strings\r\n[ok]: SORT sorted set\r\n[ok]: EXPIRE precision is now the millisecond\r\n[ok]: SORT sorted set BY nosort should retain ordering\r\n[ok]: SORT sorted set BY nosort + LIMIT\r\n[ok]: SORT sorted set BY nosort works as expected from scripts\r\n[ok]: SORT sorted set: +inf and -inf handling\r\n[ok]: Only default user has access to all channels irrespective of flag\r\n[ok]: SORT regression for issue #19, sorting floats\r\n[ok]: SORT with STORE returns zero if result is empty (github issue 224)\r\n[ok]: SORT with STORE does not create empty lists (github issue 224)\r\n[ok]: SORT with STORE removes key if result is empty (github issue 227)\r\n[ok]: SORT with BY <constant> and STORE should still order output\r\n[ok]: SORT will complain with numerical sorting and bad doubles (1)\r\n[ok]: SORT will complain with numerical sorting and bad doubles (2)\r\n[ok]: SORT BY sub-sorts lexicographically if score is the same\r\n[ok]: SORT GET with pattern ending with just -> does not get hash field\r\n[ok]: SORT by nosort retains native order for lists\r\n[ok]: SORT by nosort plus store retains native order for lists\r\n[ok]: SORT by nosort with limit returns based on original list order\r\n[ok]: Check if list is still ok after a DEBUG RELOAD - quicklist\r\n[ok]: SORT speed, 100 element list BY key, 100 times\r\n[ok]: SORT speed, 100 element list BY hash field, 100 times\r\n[ok]: SORT speed, 100 element list directly, 100 times\r\n[ok]: SORT speed, 100 element list BY <const>, 100 times\r\n[ok]: LTRIM stress testing - linkedlist\r\n[ok]: LINDEX consistency test - quicklist\r\n[12/64 done]: unit/sort (5 seconds)\r\nTesting integration/replication-2\r\n[ok]: LINDEX random access - quicklist\r\n[ok]: default: load from config file, can access any channels\r\n[ok]: XDEL fuzz test\r\n[ok]: Check if list is still ok after a DEBUG RELOAD - quicklist\r\n[ok]: LLEN against non-list value error\r\n[ok]: LLEN against non existing key\r\n[ok]: LINDEX against non-list value error\r\n[ok]: LINDEX against non existing key\r\n[ok]: LPUSH against non-list value error\r\n[ok]: RPUSH against non-list value error\r\n[ok]: RPOPLPUSH base case - linkedlist\r\n[ok]: LMOVE left left base case - linkedlist\r\n[ok]: LMOVE left right base case - linkedlist\r\n[ok]: LMOVE right left base case - linkedlist\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: If min-slaves-to-write is honored, write is accepted\r\n[ok]: LMOVE right right base case - linkedlist\r\n[ok]: No write if min-slaves-to-write is < attached slaves\r\n[ok]: If min-slaves-to-write is honored, write is accepted (again)\r\n[ok]: RPOPLPUSH with the same list as src and dst - linkedlist\r\n[ok]: LMOVE left left with the same list as src and dst - linkedlist\r\n[ok]: LMOVE left right with the same list as src and dst - linkedlist\r\n[ok]: LMOVE right left with the same list as src and dst - linkedlist\r\n[ok]: LMOVE right right with the same list as src and dst - linkedlist\r\n[ok]: RPOPLPUSH with linkedlist source and existing target linkedlist\r\n[13/64 done]: unit/acl (2 seconds)\r\nTesting integration/replication-3\r\n[ok]: LMOVE left left with linkedlist source and existing target linkedlist\r\n[ok]: LMOVE left right with linkedlist source and existing target linkedlist\r\n[ok]: LMOVE right left with linkedlist source and existing target linkedlist\r\n[ok]: LMOVE right right with linkedlist source and existing target linkedlist\r\n[ok]: RPOPLPUSH with linkedlist source and existing target ziplist\r\n[ok]: LMOVE left left with linkedlist source and existing target ziplist\r\n[ok]: LMOVE left right with linkedlist source and existing target ziplist\r\n[ok]: LMOVE right left with linkedlist source and existing target ziplist\r\n[ok]: LMOVE right right with linkedlist source and existing target ziplist\r\n[ok]: RPOPLPUSH base case - ziplist\r\n[ok]: LMOVE left left base case - ziplist\r\n[ok]: LMOVE left right base case - ziplist\r\n[ok]: LMOVE right left base case - ziplist\r\n[ok]: LMOVE right right base case - ziplist\r\n[ok]: RPOPLPUSH with the same list as src and dst - ziplist\r\n[ok]: LMOVE left left with the same list as src and dst - ziplist\r\n[ok]: LMOVE left right with the same list as src and dst - ziplist\r\n[ok]: LMOVE right left with the same list as src and dst - ziplist\r\n[ok]: LMOVE right right with the same list as src and dst - ziplist\r\n[ok]: RPOPLPUSH with ziplist source and existing target linkedlist\r\n[ok]: LMOVE left left with ziplist source and existing target linkedlist\r\n[ok]: LMOVE left right with ziplist source and existing target linkedlist\r\n[ok]: LMOVE right left with ziplist source and existing target linkedlist\r\n[ok]: LMOVE right right with ziplist source and existing target linkedlist\r\n[ok]: RPOPLPUSH with ziplist source and existing target ziplist\r\n[ok]: LMOVE left left with ziplist source and existing target ziplist\r\n[ok]: LMOVE left right with ziplist source and existing target ziplist\r\n[ok]: LMOVE right left with ziplist source and existing target ziplist\r\n[ok]: LMOVE right right with ziplist source and existing target ziplist\r\n[ok]: RPOPLPUSH against non existing key\r\n[ok]: RPOPLPUSH against non list src key\r\n[ok]: RPOPLPUSH against non list dst key\r\n[ok]: RPOPLPUSH against non existing src key\r\n[ok]: Basic LPOP/RPOP - linkedlist\r\n[ok]: Basic LPOP/RPOP - ziplist\r\n[ok]: LPOP/RPOP against non list value\r\n[ok]: Mass RPOP/LPOP - quicklist\r\n[ok]: Mass RPOP/LPOP - quicklist\r\n[ok]: LRANGE basics - linkedlist\r\n[ok]: LRANGE inverted indexes - linkedlist\r\n[ok]: LRANGE out of range indexes including the full list - linkedlist\r\n[ok]: LRANGE out of range negative end index - linkedlist\r\n[ok]: LRANGE basics - ziplist\r\n[ok]: LRANGE inverted indexes - ziplist\r\n[ok]: LRANGE out of range indexes including the full list - ziplist\r\n[ok]: LRANGE out of range negative end index - ziplist\r\n[ok]: LRANGE against non existing key\r\n[ok]: LRANGE with start > end yields an empty array for backward compatibility\r\n[ok]: LTRIM basics - linkedlist\r\n[ok]: LTRIM out of range negative end index - linkedlist\r\n[ok]: LTRIM basics - ziplist\r\n[ok]: LTRIM out of range negative end index - ziplist\r\n[ok]: LSET - linkedlist\r\n[ok]: LSET out of range index - linkedlist\r\n[ok]: LSET - ziplist\r\n[ok]: LSET out of range index - ziplist\r\n[ok]: LSET against non existing key\r\n[ok]: LSET against non list value\r\n[ok]: LREM remove all the occurrences - linkedlist\r\n[ok]: LREM remove the first occurrence - linkedlist\r\n[ok]: LREM remove non existing element - linkedlist\r\n[ok]: LREM starting from tail with negative count - linkedlist\r\n[ok]: LREM starting from tail with negative count (2) - linkedlist\r\n[ok]: LREM deleting objects that may be int encoded - linkedlist\r\n[ok]: LREM remove all the occurrences - ziplist\r\n[ok]: LREM remove the first occurrence - ziplist\r\n[ok]: LREM remove non existing element - ziplist\r\n[ok]: LREM starting from tail with negative count - ziplist\r\n[ok]: LREM starting from tail with negative count (2) - ziplist\r\n[ok]: LREM deleting objects that may be int encoded - ziplist\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: SETNX against expired volatile key\r\n[ok]: GETEX EX option\r\n[ok]: GETEX PX option\r\n[ok]: GETEX EXAT option\r\n[ok]: GETEX PXAT option\r\n[ok]: GETEX PERSIST option\r\n[ok]: GETEX no option\r\n[ok]: GETEX syntax errors\r\n[ok]: GETEX no arguments\r\n[ok]: GETDEL command\r\n[ok]: GETDEL propagate as DEL command to replica\r\n[ok]: GETEX without argument does not propagate to replica\r\n[ok]: MGET\r\n[ok]: MGET against non existing key\r\n[ok]: MGET against non-string key\r\n[ok]: GETSET (set new value)\r\n[ok]: GETSET (replace old value)\r\n[ok]: MSET base case\r\n[ok]: MSET wrong number of args\r\n[ok]: MSETNX with already existent key\r\n[ok]: MSETNX with not existing keys\r\n[ok]: STRLEN against non-existing key\r\n[ok]: STRLEN against integer-encoded value\r\n[ok]: STRLEN against plain string\r\n[ok]: SETBIT against non-existing key\r\n[ok]: SETBIT against string-encoded key\r\n[ok]: SETBIT against integer-encoded key\r\n[ok]: SETBIT against key with wrong type\r\n[ok]: SETBIT with out of range bit offset\r\n[ok]: SETBIT with non-bit argument\r\n[ok]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires\r\n[ok]: TTL returns time to live in seconds\r\n[ok]: PTTL returns time to live in milliseconds\r\n[ok]: TTL / PTTL return -1 if key has no expire\r\n[ok]: TTL / PTTL return -2 if key does not exit\r\n[ok]: ZDIFF fuzzing - skiplist\r\n[ok]: Basic ZPOP with a single key - skiplist\r\n[ok]: ZPOP with count - skiplist\r\n[ok]: BZPOP with a single existing sorted set - skiplist\r\n[ok]: BZPOP with multiple existing sorted sets - skiplist\r\n[ok]: BZPOP second sorted set has members - skiplist\r\n[ok]: ZINTERSTORE regression with two sets, intset+hashtable\r\n[ok]: ZUNIONSTORE regression, should not create NaN in scores\r\n[ok]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets\r\n[ok]: SETBIT fuzzing\r\n[ok]: GETBIT against non-existing key\r\n[ok]: GETBIT against string-encoded key\r\n[ok]: GETBIT against integer-encoded key\r\n[ok]: SETRANGE against non-existing key\r\n[ok]: SETRANGE against string-encoded key\r\n[ok]: SETRANGE against integer-encoded key\r\n[ok]: SETRANGE against key with wrong type\r\n[ok]: SETRANGE with out of range offset\r\n[ok]: GETRANGE against non-existing key\r\n[ok]: GETRANGE against string value\r\n[ok]: GETRANGE against integer-encoded value\r\n[ok]: ZUNIONSTORE result is sorted\r\n[ok]: ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE error if using WITHSCORES \r\n[ok]: ZMSCORE retrieve\r\n[ok]: ZMSCORE retrieve from empty set\r\n[ok]: ZMSCORE retrieve with missing member\r\n[ok]: ZMSCORE retrieve single member\r\n[ok]: ZMSCORE retrieve requires one or more members\r\n[ok]: ZSET commands don't accept the empty strings as valid score\r\n[ok]: ZSCORE - ziplist\r\n[ok]: ZMSCORE - ziplist\r\n[ok]: ZSCORE after a DEBUG RELOAD - ziplist\r\n[ok]: ZSET sorting stresser - ziplist\r\n[ok]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds\r\n[ok]: client unblock tests\r\n[ok]: List ziplist of various encodings\r\n[ok]: List ziplist of various encodings - sanitize dump\r\n[ok]: SCAN regression test for issue #4906\r\n[14/64 done]: unit/type/list (8 seconds)\r\nTesting integration/replication-4\r\n[15/64 done]: unit/scan (8 seconds)\r\nTesting integration/replication-psync\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no reconnection, just sync (diskless: no, disabled, reconnect: 0)\r\n[ok]: GETRANGE fuzzing\r\n[ok]: Extended SET can detect syntax errors\r\n[ok]: Extended SET NX option\r\n[ok]: Extended SET XX option\r\n[ok]: Extended SET GET option\r\n[ok]: Extended SET GET option with no previous value\r\n[ok]: Extended SET GET with NX option should result in syntax err\r\n[ok]: Extended SET GET with incorrect type should result in wrong type error\r\n[ok]: Extended SET EX option\r\n[ok]: Extended SET PX option\r\n[ok]: Extended SET EXAT option\r\n[ok]: Extended SET PXAT option\r\n[ok]: Extended SET using multiple options at once\r\n[ok]: GETRANGE with huge ranges, Github issue #1844\r\n[ok]: STRALGO LCS string output with STRINGS option\r\n[ok]: STRALGO LCS len\r\n[ok]: LCS with KEYS option\r\n[ok]: LCS indexes\r\n[ok]: LCS indexes with match len\r\n[ok]: LCS indexes with match len and minimum match len\r\n[ok]: Redis should actively expire keys incrementally\r\n[16/64 done]: unit/type/string (8 seconds)\r\nTesting integration/aof\r\n[ok]: Unfinished MULTI: Server should start if load-truncated is yes\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Short read: Server should start if load-truncated is yes\r\n[ok]: Truncated AOF loaded: we expect foo to be equal to 5\r\n[ok]: Append a new command after loading an incomplete AOF\r\n[ok]: Short read + command: Server should start\r\n[ok]: Truncated AOF loaded: we expect foo to be equal to 6 now\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: Test latency events logging\r\n[ok]: LATENCY HISTORY output is ok\r\n[ok]: LATENCY LATEST output is ok\r\n[ok]: LATENCY HISTORY / RESET with wrong event name is fine\r\n[ok]: LATENCY DOCTOR produces some output\r\n[ok]: LATENCY RESET is able to reset events\r\n[ok]: Bad format: Server should have logged an error\r\n[ok]: EXPIRES after AOF reload (without rewrite)\r\n[ok]: Unfinished MULTI: Server should have logged an error\r\n[ok]: Short read: Server should have logged an error\r\n[ok]: Short read: Utility should confirm the AOF is not valid\r\n[ok]: Short read: Utility should be able to fix the AOF\r\n[ok]: Fixed AOF: Server should have been started\r\n[ok]: Fixed AOF: Keyspace should contain values that were parseable\r\n[ok]: No write if min-slaves-max-lag is > of the slave lag\r\n[ok]: Redis should lazy expire keys\r\n[ok]: min-slaves-to-write is ignored by slaves\r\n[ok]: Detect write load to master\r\n[ok]: AOF+SPOP: Server should have been started\r\n[ok]: AOF+SPOP: Set should have 1 member\r\n[ok]: AOF+SPOP: Server should have been started\r\n[ok]: AOF+SPOP: Set should have 1 member\r\n[ok]: ZRANGEBYSCORE fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[ok]: ZRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[ok]: AOF+EXPIRE: Server should have been started\r\n[ok]: AOF+EXPIRE: List should be empty\r\n[ok]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist\r\n[ok]: ZSETs skiplist implementation backlink consistency test - ziplist\r\n[ok]: Redis should not try to convert DEL into EXPIREAT for EXPIRE -1\r\n[ok]: EXPIRE should not resurrect keys (issue #1026)\r\n[ok]: 5 keys in, 5 keys out\r\n[ok]: EXPIRE with empty string as TTL should report an error\r\n[ok]: SET with EX with big integer should report an error\r\n[ok]: SET with EX with smallest integer should report an error\r\n[ok]: GETEX with big integer should report an error\r\n[ok]: GETEX with smallest integer should report an error\r\n[ok]: EXPIRE with big integer overflows when converted to milliseconds\r\n[ok]: PEXPIRE with big integer overflow when basetime is added\r\n[ok]: EXPIRE with big negative integer\r\n[ok]: PEXPIREAT with big integer works\r\n[ok]: PEXPIREAT with big negative integer works\r\n[ok]: PIPELINING stresser (also a regression for the old epoll bug)\r\n[ok]: APPEND basics\r\n[ok]: APPEND basics, integer encoded values\r\n[ok]: APPEND fuzzing\r\n[ok]: FLUSHDB\r\n[ok]: Perform a final SAVE to leave a clean DB on disk\r\n[ok]: RESET clears client state\r\n[ok]: RESET clears MONITOR state\r\n[ok]: RESET clears and discards MULTI state\r\n[ok]: RESET clears Pub/Sub state\r\n[ok]: RESET clears authenticated state\r\n[ok]: ZSETs ZRANK augmented skip list stress testing - ziplist\r\n[ok]: BZPOPMIN, ZADD + DEL should not awake blocked client\r\n[ok]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client\r\n[ok]: BZPOPMIN with same key multiple times should work\r\n[ok]: MULTI/EXEC is isolated from the point of view of BZPOPMIN\r\n[ok]: BZPOPMIN with variadic ZADD\r\n[ok]: Don't rehash if redis has child proecess\r\n[ok]: Process title set as expected\r\n[17/64 done]: unit/other (11 seconds)\r\nTesting integration/rdb\r\n[ok]: RDB encoding loading test\r\n[ok]: LTRIM stress testing - ziplist\r\n[ok]: BZPOPMIN with zero timeout should block indefinitely\r\n[ok]: ZSCORE - skiplist\r\n[ok]: ZMSCORE - skiplist\r\n[ok]: ZSCORE after a DEBUG RELOAD - skiplist\r\n[18/64 done]: unit/type/list-2 (12 seconds)\r\nTesting integration/corrupt-dump\r\n[ok]: ZSET sorting stresser - skiplist\r\n[ok]: Server started empty with non-existing RDB file\r\n[ok]: corrupt payload: #7445 - with sanitize\r\n[ok]: EXPIRE and SET/GETEX EX/PX/EXAT/PXAT option, TTL should not be reset after loadaof\r\n[ok]: Server started empty with empty RDB file\r\n[ok]: corrupt payload: #7445 - without sanitize - 1\r\n[ok]: EXPIRE relative and absolute propagation to replicas\r\n[ok]: SET command will remove expire\r\n[ok]: SET - use KEEPTTL option, TTL should not be removed\r\n[ok]: corrupt payload: #7445 - without sanitize - 2\r\n[ok]: Test RDB stream encoding\r\n[ok]: Test RDB stream encoding - sanitize dump\r\n[ok]: corrupt payload: hash with valid zip list header, invalid entry len\r\n[ok]: Server should not start if RDB is corrupted\r\n[ok]: corrupt payload: invalid zlbytes header\r\n[ok]: corrupt payload: valid zipped hash header, dup records\r\n[ok]: Test FLUSHALL aborts bgsave\r\n[ok]: bgsave resets the change counter\r\n[ok]: corrupt payload: quicklist big ziplist prev len\r\n[ok]: corrupt payload: quicklist small ziplist prev len\r\n[ok]: corrupt payload: quicklist ziplist wrong count\r\n[ok]: corrupt payload: #3080 - quicklist\r\n[ok]: ZRANGEBYSCORE fuzzy test, 100 ranges in 100 element sorted set - skiplist\r\n[ok]: corrupt payload: #3080 - ziplist\r\n[ok]: corrupt payload: load corrupted rdb with no CRC - #3505\r\n[ok]: ZRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist\r\n[ok]: corrupt payload: listpack invalid size header\r\n[ok]: corrupt payload: listpack too long entry len\r\n[ok]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist\r\n[ok]: ZSETs skiplist implementation backlink consistency test - skiplist\r\n[ok]: corrupt payload: listpack very long entry len\r\n[ok]: corrupt payload: listpack too long entry prev len\r\n[ok]: SET - use KEEPTTL option, TTL should not be removed after loadaof\r\n[ok]: GETEX use of PERSIST option should remove TTL\r\n[ok]: corrupt payload: hash ziplist with duplicate records\r\n[ok]: MASTER and SLAVE consistency with expire\r\n[ok]: corrupt payload: hash ziplist uneven record count\r\n[ok]: ZSETs ZRANK augmented skip list stress testing - skiplist\r\n[ok]: BZPOPMIN, ZADD + DEL should not awake blocked client\r\n[ok]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client\r\n[ok]: BZPOPMIN with same key multiple times should work\r\n[ok]: MULTI/EXEC is isolated from the point of view of BZPOPMIN\r\n[ok]: BZPOPMIN with variadic ZADD\r\n[ok]: corrupt payload: hash dupliacte records\r\n[ok]: Test replication with parallel clients writing in different DBs\r\n[ok]: corrupt payload: fuzzer findings - NPD in streamIteratorGetID\r\n[ok]: LATENCY of expire events are correctly collected\r\n[ok]: LATENCY HELP should not have unexpected options\r\n[ok]: corrupt payload: fuzzer findings - listpack NPD on invalid stream\r\n[ok]: corrupt payload: fuzzer findings - NPD in quicklistIndex\r\n[ok]: corrupt payload: fuzzer findings - invalid read in ziplistFind\r\n[19/64 done]: unit/latency-monitor (9 seconds)\r\nTesting integration/corrupt-dump-fuzzer\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: With min-slaves-to-write (1,3): master should be writable\r\n[ok]: With min-slaves-to-write (2,3): master should not be writable\r\n[ok]: corrupt payload: fuzzer findings - invalid ziplist encoding\r\n[ok]: MIGRATE cached connections are released after some time\r\n[ok]: corrupt payload: fuzzer findings - hash crash\r\n[ok]: MIGRATE is able to migrate a key between two instances\r\n[ok]: corrupt payload: fuzzer findings - uneven entry count in hash\r\n[ok]: Slave is able to detect timeout during handshake\r\n[ok]: BZPOPMIN with zero timeout should block indefinitely\r\n[ok]: MASTER and SLAVE dataset should be identical after complex ops\r\n[ok]: AOF fsync always barrier issue\r\n[ok]: MIGRATE is able to copy a key between two instances\r\n[ok]: corrupt payload: fuzzer findings - invalid read in lzf_decompress\r\n[ok]: client freed during loading\r\n[ok]: GETEX should not append to AOF\r\n[20/64 done]: integration/replication-2 (10 seconds)\r\nTesting integration/convert-zipmap-hash-on-load\r\n[ok]: RDB load zipmap hash: converts to ziplist\r\n[ok]: MIGRATE will not overwrite existing keys, unless REPLACE is used\r\n[ok]: corrupt payload: fuzzer findings - leak in rdbloading due to dup entry in set\r\n[21/64 done]: integration/aof (8 seconds)\r\nTesting integration/logging\r\n[ok]: corrupt payload: fuzzer findings - empty intset div by zero\r\n[ok]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-entries is exceeded\r\n[ok]: Set instance A as slave of B\r\n[ok]: corrupt payload: fuzzer findings - valgrind ziplist - crash report prints freed memory\r\n[ok]: Test replication partial resync: ok psync (diskless: no, disabled, reconnect: 1)\r\n[ok]: MIGRATE propagates TTL correctly\r\n[ok]: corrupt payload: fuzzer findings - valgrind ziplist prevlen reaches outside the ziplist\r\n[ok]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-value is exceeded\r\n[ok]: ZSET skiplist order consistency when elements are moved\r\n[ok]: ZRANGESTORE basic\r\n[ok]: ZRANGESTORE RESP3\r\n[ok]: ZRANGESTORE range\r\n[ok]: ZRANGESTORE BYLEX\r\n[ok]: ZRANGESTORE BYSCORE\r\n[ok]: ZRANGESTORE BYSCORE LIMIT\r\n[ok]: ZRANGESTORE BYSCORE REV LIMIT\r\n[ok]: ZRANGE BYSCORE REV LIMIT\r\n[ok]: ZRANGESTORE - empty range\r\n[ok]: ZRANGESTORE BYLEX - empty range\r\n[ok]: ZRANGESTORE BYSCORE - empty range\r\n[ok]: ZRANGE BYLEX\r\n[ok]: ZRANGESTORE invalid syntax\r\n[ok]: ZRANGE invalid syntax\r\n[ok]: Server is able to generate a stack trace on selected systems\r\n[ok]: ZRANDMEMBER - ziplist\r\n[ok]: ZRANDMEMBER - skiplist\r\n[ok]: ZRANDMEMBER with RESP3\r\n[ok]: ZRANDMEMBER count of 0 is handled correctly\r\n[ok]: ZRANDMEMBER with <count> against non existing key\r\n[22/64 done]: integration/convert-zipmap-hash-on-load (1 seconds)\r\nTesting integration/psync2\r\n[ok]: GETEX use of PERSIST option should remove TTL after loadaof\r\n[ok]: corrupt payload: fuzzer findings - valgrind - bad rdbLoadDoubleValue\r\n[ok]: corrupt payload: fuzzer findings - valgrind ziplist prev too big\r\n[ok]: GETEX propagate as to replica as PERSIST, DEL, or nothing\r\n[ok]: ZRANDMEMBER with <count> - skiplist\r\n[ok]: ZRANDMEMBER with <count> - ziplist\r\n[23/64 done]: unit/expire (16 seconds)\r\nTesting integration/psync2-reg\r\n[24/64 done]: unit/type/zset (17 seconds)\r\nTesting integration/psync2-pingoff\r\n[ok]: Crash report generated on SIGABRT\r\n[ok]: AOF rewrite during write load: RDB preamble=yes\r\n[ok]: corrupt payload: fuzzer findings - lzf decompression fails, avoid valgrind invalid read\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: PSYNC2: --- CYCLE 1 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #1 as master\r\n[ok]: PSYNC2: Set #4 to replicate from #1\r\n[ok]: PSYNC2: Set #0 to replicate from #1\r\n[ok]: PSYNC2: Set #3 to replicate from #4\r\n[ok]: PSYNC2: Set #2 to replicate from #4\r\n[ok]: corrupt payload: fuzzer findings - stream bad lp_count\r\n[25/64 done]: integration/logging (1 seconds)\r\nTesting integration/failover\r\n[ok]: INCRBYFLOAT replication, should not remove expire\r\n[ok]: GETSET replication\r\n[ok]: BRPOPLPUSH replication, when blocking against empty list\r\n[ok]: corrupt payload: fuzzer findings - stream bad lp_count - unsanitized\r\n[ok]: failover command fails without connected replica\r\n[ok]: corrupt payload: fuzzer findings - stream integrity check issue\r\n[ok]: setup replication for following tests\r\n[ok]: failover command fails with invalid host\r\n[ok]: failover command fails with invalid port\r\n[ok]: failover command fails with just force and timeout\r\n[ok]: failover command fails when sent to a replica\r\n[ok]: failover command fails with force without timeout\r\n[ok]: corrupt payload: fuzzer findings - infinite loop\r\n[ok]: corrupt payload: fuzzer findings - hash convert asserts on RESTORE with shallow sanitization\r\n[ok]: PSYNC2 pingoff: setup\r\n[ok]: PSYNC2 pingoff: write and wait replication\r\n[ok]: PSYNC2 #3899 regression: setup\r\n[ok]: corrupt payload: OOM in rdbGenericLoadStringObject\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: BRPOPLPUSH replication, list exists\r\n[ok]: BLMOVE (left, left) replication, when blocking against empty list\r\n[ok]: With min-slaves-to-write: master not writable with lagged slave\r\n[ok]: corrupt payload: fuzzer findings - OOM in dictExpand\r\n[ok]: corrupt payload: fuzzer findings - invalid tail offset after removal\r\n[ok]: failover command to specific replica works\r\n[ok]: corrupt payload: fuzzer findings - negative reply length\r\n[ok]: corrupt payload: fuzzer findings - valgrind negative malloc\r\n[ok]: Test child sending info\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: BLMOVE (left, left) replication, list exists\r\n[ok]: BLMOVE (left, right) replication, when blocking against empty list\r\n[26/64 done]: integration/rdb (7 seconds)\r\nTesting integration/redis-cli\r\n[ok]: corrupt payload: fuzzer findings - valgrind invalid read\r\n[ok]: Interactive CLI: INFO response should be printed raw\r\n[ok]: Interactive CLI: Status reply\r\n[ok]: failover command to any replica works\r\n[ok]: Interactive CLI: Integer reply\r\n[ok]: Interactive CLI: Bulk reply\r\n[ok]: Interactive CLI: Multi-bulk reply\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: corrupt payload: fuzzer findings - HRANDFIELD on bad ziplist\r\n[ok]: Interactive CLI: Parsing quotes\r\n[ok]: Non-interactive TTY CLI: Status reply\r\n[ok]: Non-interactive TTY CLI: Integer reply\r\n[ok]: Non-interactive TTY CLI: Bulk reply\r\n[ok]: corrupt payload: fuzzer findings - stream with no records\r\n[ok]: Non-interactive TTY CLI: Multi-bulk reply\r\n[27/64 done]: integration/corrupt-dump (8 seconds)\r\nTesting integration/redis-benchmark\r\n[ok]: Non-interactive TTY CLI: Read last argument from pipe\r\n[ok]: Non-interactive TTY CLI: Read last argument from file\r\n[ok]: Non-interactive non-TTY CLI: Status reply\r\n[ok]: Non-interactive non-TTY CLI: Integer reply\r\n[ok]: failover to a replica with force works\r\n[ok]: Non-interactive non-TTY CLI: Bulk reply\r\n[ok]: Non-interactive non-TTY CLI: Multi-bulk reply\r\n[ok]: Non-interactive non-TTY CLI: Quoted input arguments\r\n[ok]: Non-interactive non-TTY CLI: No accidental unquoting of input arguments\r\n[ok]: Non-interactive non-TTY CLI: Invalid quoted input arguments\r\n[ok]: benchmark: set,get\r\n[ok]: Non-interactive non-TTY CLI: Read last argument from pipe\r\n[ok]: Non-interactive non-TTY CLI: Read last argument from file\r\n[ok]: benchmark: full test suite\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: BLMOVE (left, right) replication, list exists\r\n[ok]: BLMOVE (right, left) replication, when blocking against empty list\r\n[ok]: failover with timeout aborts if replica never catches up\r\n[ok]: failovers can be aborted\r\n[ok]: Slave is able to evict keys created in writable slaves\r\n[ok]: benchmark: multi-thread set,get\r\n[ok]: First server should have role slave after SLAVEOF\r\n[ok]: benchmark: pipelined full set,get\r\n[ok]: benchmark: arbitrary command\r\n[ok]: BLMOVE (right, left) replication, list exists\r\n[ok]: BLMOVE (right, right) replication, when blocking against empty list\r\n[ok]: benchmark: keyspace length\r\n[ok]: failover aborts if target rejects sync request\r\n[28/64 done]: integration/redis-benchmark (2 seconds)\r\nTesting unit/pubsub\r\n[ok]: Pub/Sub PING\r\n[ok]: PUBLISH/SUBSCRIBE basics\r\n[ok]: PUBLISH/SUBSCRIBE with two clients\r\n[ok]: PUBLISH/SUBSCRIBE after UNSUBSCRIBE without arguments\r\n[ok]: SUBSCRIBE to one channel more than once\r\n[ok]: UNSUBSCRIBE from non-subscribed channels\r\n[ok]: PUBLISH/PSUBSCRIBE basics\r\n[ok]: PUBLISH/PSUBSCRIBE with two clients\r\n[ok]: PUBLISH/PSUBSCRIBE after PUNSUBSCRIBE without arguments\r\n[ok]: PUNSUBSCRIBE from non-subscribed channels\r\n[ok]: NUMSUB returns numbers, not strings (#1561)\r\n[ok]: Mix SUBSCRIBE and PSUBSCRIBE\r\n[ok]: PUNSUBSCRIBE and UNSUBSCRIBE should always reply\r\n[ok]: Keyspace notifications: we receive keyspace notifications\r\n[ok]: Keyspace notifications: we receive keyevent notifications\r\n[ok]: Keyspace notifications: we can receive both kind of events\r\n[ok]: Keyspace notifications: we are able to mask events\r\n[ok]: Keyspace notifications: general events test\r\n[ok]: Keyspace notifications: list events test\r\n[ok]: Keyspace notifications: set events test\r\n[ok]: Keyspace notifications: zset events test\r\n[ok]: Keyspace notifications: hash events test\r\n[ok]: XRANGE fuzzing\r\n[ok]: XREVRANGE regression test for issue #5006\r\n[ok]: XREAD streamID edge (no-blocking)\r\n[ok]: XREAD streamID edge (blocking)\r\n[ok]: XADD streamID edge\r\n[ok]: XTRIM with MAXLEN option basic test\r\n[ok]: XADD with LIMIT consecutive calls\r\n[ok]: XTRIM with ~ is limited\r\n[ok]: XTRIM without ~ is not limited\r\n[ok]: XTRIM without ~ and with LIMIT\r\n[ok]: Keyspace notifications: expired events (triggered expire)\r\n[ok]: Keyspace notifications: expired events (background expire)\r\n[ok]: Keyspace notifications: evicted events\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: Keyspace notifications: test CONFIG GET/SET of event flags\r\n[29/64 done]: integration/failover (5 seconds)\r\nTesting unit/slowlog\r\n[ok]: SLOWLOG - check that it starts with an empty log\r\n[30/64 done]: unit/pubsub (0 seconds)\r\nTesting unit/scripting\r\n[ok]: EVAL - Does Lua interpreter replies to our requests?\r\n[ok]: EVAL - Lua integer -> Redis protocol type conversion\r\n[ok]: EVAL - Lua string -> Redis protocol type conversion\r\n[ok]: EVAL - Lua true boolean -> Redis protocol type conversion\r\n[ok]: EVAL - Lua false boolean -> Redis protocol type conversion\r\n[ok]: EVAL - Lua status code reply -> Redis protocol type conversion\r\n[ok]: EVAL - Lua error reply -> Redis protocol type conversion\r\n[ok]: EVAL - Lua table -> Redis protocol type conversion\r\n[ok]: XADD with MAXLEN > xlen can propagate correctly\r\n[ok]: EVAL - Are the KEYS and ARGV arrays populated correctly?\r\n[ok]: EVAL - is Lua able to call Redis API?\r\n[ok]: EVALSHA - Can we call a SHA1 if already defined?\r\n[ok]: EVALSHA - Can we call a SHA1 in uppercase?\r\n[ok]: EVALSHA - Do we get an error on invalid SHA1?\r\n[ok]: EVALSHA - Do we get an error on non defined SHA1?\r\n[ok]: EVAL - Redis integer -> Lua type conversion\r\n[ok]: EVAL - Redis bulk -> Lua type conversion\r\n[ok]: EVAL - Redis multi bulk -> Lua type conversion\r\n[ok]: EVAL - Redis status reply -> Lua type conversion\r\n[ok]: EVAL - Redis error reply -> Lua type conversion\r\n[ok]: EVAL - Redis nil bulk reply -> Lua type conversion\r\n[ok]: EVAL - Is the Lua client using the currently selected DB?\r\n[ok]: EVAL - SELECT inside Lua should not affect the caller\r\n[ok]: EVAL - Scripts can't run blpop command\r\n[ok]: EVAL - Scripts can't run brpop command\r\n[ok]: EVAL - Scripts can't run brpoplpush command\r\n[ok]: EVAL - Scripts can't run blmove command\r\n[ok]: EVAL - Scripts can't run bzpopmin command\r\n[ok]: EVAL - Scripts can't run bzpopmax command\r\n[ok]: EVAL - Scripts can't run XREAD and XREADGROUP with BLOCK option\r\n[ok]: EVAL - Scripts can't run certain commands\r\n[ok]: EVAL - No arguments to redis.call/pcall is considered an error\r\n[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)\r\n[ok]: EVAL - JSON numeric decoding\r\n[ok]: EVAL - JSON string decoding\r\n[ok]: EVAL - cmsgpack can pack double?\r\n[ok]: EVAL - cmsgpack can pack negative int64?\r\n[ok]: EVAL - cmsgpack can pack and unpack circular references?\r\n[ok]: EVAL - Numerical sanity check from bitop\r\n[ok]: EVAL - Verify minimal bitop functionality\r\n[ok]: EVAL - Able to parse trailing comments\r\n[ok]: SCRIPTING FLUSH - is able to clear the scripts cache?\r\n[ok]: SCRIPTING FLUSH ASYNC\r\n[ok]: SCRIPT EXISTS - can detect already defined scripts?\r\n[ok]: SCRIPT LOAD - is able to register scripts in the scripting cache\r\n[ok]: In the context of Lua the output of random commands gets ordered\r\n[ok]: SORT is normally not alpha re-ordered for the scripting engine\r\n[ok]: SORT BY <constant> output gets ordered for scripting\r\n[ok]: SORT BY <constant> with GET gets ordered for scripting\r\n[ok]: redis.sha1hex() implementation\r\n[ok]: Globals protection reading an undeclared global variable\r\n[ok]: Globals protection setting an undeclared global*\r\n[ok]: Test an example script DECR_IF_GT\r\n[ok]: Scripting engine resets PRNG at every script execution\r\n[ok]: Scripting engine PRNG can be seeded correctly\r\n[ok]: SLOWLOG - only logs commands taking more time than specified\r\n[ok]: SLOWLOG - max entries is correctly handled\r\n[ok]: SLOWLOG - GET optional argument to limit output len works\r\n[ok]: SLOWLOG - RESET subcommand works\r\n[ok]: BLMOVE (right, right) replication, list exists\r\n[ok]: BLPOP followed by role change, issue #2473\r\n[ok]: SLOWLOG - logged entry sanity check\r\n[ok]: SLOWLOG - Certain commands are omitted that contain sensitive information\r\n[ok]: SLOWLOG - Rewritten commands are logged as their original command\r\n[ok]: SLOWLOG - commands with too many arguments are trimmed\r\n[ok]: SLOWLOG - too long arguments are trimmed\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: XADD with MINID > lastid can propagate correctly\r\n[ok]: SLOWLOG - EXEC is not logged, just executed commands\r\n[ok]: SLOWLOG - can clean older entries\r\n[ok]: PSYNC2 pingoff: pause replica and promote it\r\n[ok]: XADD with ~ MAXLEN can propagate correctly\r\n[ok]: EVAL does not leak in the Lua stack\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 29410)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 2 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #1 as master\r\n[ok]: PSYNC2: Set #4 to replicate from #1\r\n[ok]: PSYNC2: Set #2 to replicate from #1\r\n[ok]: PSYNC2: Set #3 to replicate from #1\r\n[ok]: PSYNC2: Set #0 to replicate from #4\r\n[ok]: EVAL processes writes from AOF in read-only slaves\r\n[ok]: Second server should have role master at first\r\n[ok]: SLAVEOF should start with link status \"down\"\r\n[ok]: The role should immediately be changed to \"replica\"\r\n[ok]: MIGRATE can correctly transfer large values\r\n[ok]: SLOWLOG - can be disabled\r\n[ok]: Dumping an RDB\r\n[ok]: XADD with ~ MAXLEN and LIMIT can propagate correctly\r\n[ok]: Sync should have transferred keys from master\r\n[ok]: The link status should be up\r\n[ok]: SET on the master should immediately propagate\r\n[ok]: FLUSHALL should replicate\r\n[ok]: ROLE in master reports master with a slave\r\n[ok]: ROLE in slave reports slave in connected state\r\n[ok]: Scan mode\r\n[31/64 done]: unit/slowlog (2 seconds)\r\nTesting unit/maxmemory\r\n[ok]: MIGRATE can correctly transfer hashes\r\n[ok]: Without maxmemory small integers are shared\r\n[ok]: With maxmemory and non-LRU policy integers are still shared\r\n[ok]: With maxmemory and LRU policy integers are not shared\r\n[ok]: XADD with ~ MINID can propagate correctly\r\n[ok]: XADD with ~ MINID and LIMIT can propagate correctly\r\n[ok]: maxmemory - is the memory limit honoured? (policy allkeys-random)\r\n[ok]: Make the old master a replica of the new one and check conditions\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: XTRIM with ~ MAXLEN can propagate correctly\r\n[ok]: MIGRATE timeout actually works\r\n[ok]: maxmemory - is the memory limit honoured? (policy allkeys-lru)\r\n[ok]: Connecting as a replica\r\n[ok]: XADD can CREATE an empty stream\r\n[ok]: XSETID can set a specific ID\r\n[ok]: XSETID cannot SETID with smaller ID\r\n[ok]: XSETID cannot SETID on non-existent key\r\n[ok]: Fuzzer corrupt restore payloads - sanitize_dump: no\r\n[ok]: MIGRATE can migrate multiple keys at once\r\n[ok]: MIGRATE with multiple keys must have empty key arg\r\n[ok]: MIGRATE with multiple keys migrate just existing ones\r\n[ok]: maxmemory - is the memory limit honoured? (policy allkeys-lfu)\r\n[ok]: MIGRATE with multiple keys: stress command rewriting\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: maxmemory - is the memory limit honoured? (policy volatile-lru)\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: MIGRATE with multiple keys: delete just ack keys\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: MIGRATE AUTH: correct and wrong password cases\r\n[ok]: maxmemory - is the memory limit honoured? (policy volatile-lfu)\r\n[32/64 done]: unit/dump (26 seconds)\r\nTesting unit/introspection\r\n[ok]: CLIENT LIST\r\n[ok]: CLIENT LIST with IDs\r\n[ok]: CLIENT INFO\r\n[ok]: MONITOR can log executed commands\r\n[ok]: MONITOR can log commands issued by the scripting engine\r\n[ok]: CLIENT GETNAME should return NIL if name is not assigned\r\n[ok]: CLIENT LIST shows empty fields for unassigned names\r\n[ok]: CLIENT SETNAME does not accept spaces\r\n[ok]: CLIENT SETNAME can assign a name to this connection\r\n[ok]: CLIENT SETNAME can change the name of an existing connection\r\n[ok]: After CLIENT SETNAME, connection can still be closed\r\n[ok]: Empty stream can be rewrite into AOF correctly\r\n[ok]: Test replication partial resync: no backlog (diskless: no, disabled, reconnect: 1)\r\n[ok]: CONFIG save params special case handled properly\r\n[ok]: CONFIG sanity\r\n[ok]: Piping raw protocol\r\n[ok]: maxmemory - is the memory limit honoured? (policy volatile-random)\r\n[ok]: CONFIG REWRITE sanity\r\n[33/64 done]: integration/redis-cli (8 seconds)\r\nTesting unit/introspection-2\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: maxmemory - is the memory limit honoured? (policy volatile-ttl)\r\n[ok]: Stream can be rewrite into AOF correctly after XDEL lastid\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: XGROUP HELP should not have unexpected options\r\n[ok]: test various edge cases of repl topology changes with missing pings at the end\r\n[34/64 done]: unit/type/stream (28 seconds)\r\nTesting unit/limits\r\n[ok]: CONFIG REWRITE handles save properly\r\n[ok]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-random)\r\n[35/64 done]: unit/introspection (2 seconds)\r\nTesting unit/obuf-limits\r\n[ok]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-lru)\r\n[ok]: PSYNC2 #3899 regression: kill first replica\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: Check if maxclients works refusing connections\r\n[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-lru)\r\n[36/64 done]: unit/limits (1 seconds)\r\nTesting unit/bitops\r\n[ok]: EVAL timeout from AOF\r\n[ok]: We can call scripts rewriting client->argv from Lua\r\n[ok]: Call Redis command with many args from Lua (issue #1764)\r\n[ok]: Number conversion precision test (issue #1118)\r\n[ok]: String containing number precision test (regression of issue #1118)\r\n[ok]: Verify negative arg count is error instead of crash (issue #1842)\r\n[ok]: Correct handling of reused argv (issue #1939)\r\n[ok]: Functions in the Redis namespace are able to report errors\r\n[ok]: Script with RESP3 map\r\n[ok]: BITCOUNT returns 0 against non existing key\r\n[ok]: BITCOUNT returns 0 with out of range indexes\r\n[ok]: BITCOUNT returns 0 with negative indexes where start > end\r\n[ok]: BITCOUNT against test vector #1\r\n[ok]: BITCOUNT against test vector #2\r\n[ok]: BITCOUNT against test vector #3\r\n[ok]: BITCOUNT against test vector #4\r\n[ok]: BITCOUNT against test vector #5\r\n[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-random)\r\n[ok]: BITCOUNT fuzzing without start/end\r\n[ok]: Timedout read-only scripts can be killed by SCRIPT KILL\r\n[ok]: Timedout read-only scripts can be killed by SCRIPT KILL even when use pcall\r\n[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-ttl)\r\n[ok]: TTL, TYPE and EXISTS do not alter the last access time of a key\r\n[ok]: Timedout script does not cause a false dead client\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: BITCOUNT fuzzing with start/end\r\n[ok]: BITCOUNT with start, end\r\n[ok]: BITCOUNT syntax error #1\r\n[ok]: BITCOUNT regression test for github issue #582\r\n[ok]: BITCOUNT misaligned prefix\r\n[ok]: BITCOUNT misaligned prefix + full words + remainder\r\n[ok]: BITOP NOT (empty string)\r\n[ok]: BITOP NOT (known string)\r\n[ok]: BITOP where dest and target are the same key\r\n[ok]: BITOP AND|OR|XOR don't change the string with single input key\r\n[ok]: BITOP missing key is considered a stream of zero\r\n[ok]: BITOP shorter keys are zero-padded to the key with max length\r\n[ok]: maxmemory - policy volatile-lru should only remove volatile keys.\r\n[ok]: Timedout script link is still usable after Lua returns\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 57900)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 3 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #0 as master\r\n[ok]: PSYNC2: Set #3 to replicate from #0\r\n[ok]: PSYNC2: Set #4 to replicate from #3\r\n[ok]: PSYNC2: Set #1 to replicate from #0\r\n[ok]: PSYNC2: Set #2 to replicate from #1\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: Timedout scripts that modified data can't be killed by SCRIPT KILL\r\n[ok]: SHUTDOWN NOSAVE can kill a timedout script anyway\r\n[ok]: maxmemory - policy volatile-lfu should only remove volatile keys.\r\n[ok]: Before the replica connects we issue two EVAL commands (scripts replication)\r\n[ok]: BITOP and fuzzing\r\n[ok]: maxmemory - policy volatile-random should only remove volatile keys.\r\n[ok]: Connect a replica to the master instance (scripts replication)\r\n[ok]: Now use EVALSHA against the master, with both SHAs (scripts replication)\r\n[ok]: If EVALSHA was replicated as EVAL, 'x' should be '4' (scripts replication)\r\n[ok]: Replication of script multiple pushes to list with BLPOP (scripts replication)\r\n[ok]: EVALSHA replication when first call is readonly (scripts replication)\r\n[ok]: Lua scripts using SELECT are replicated correctly (scripts replication)\r\n[ok]: maxmemory - policy volatile-ttl should only remove volatile keys.\r\n[ok]: BITOP or fuzzing\r\n[ok]: Before the replica connects we issue two EVAL commands (commands replication)\r\n[ok]: Connect a replica to the master instance (commands replication)\r\n[ok]: Now use EVALSHA against the master, with both SHAs (commands replication)\r\n[ok]: If EVALSHA was replicated as EVAL, 'x' should be '4' (commands replication)\r\n[ok]: Replication of script multiple pushes to list with BLPOP (commands replication)\r\n[ok]: EVALSHA replication when first call is readonly (commands replication)\r\n[ok]: Lua scripts using SELECT are replicated correctly (commands replication)\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: Chained replicas disconnect when replica re-connect with the same master\r\n[ok]: BITOP xor fuzzing\r\n[ok]: BITOP NOT fuzzing\r\n[ok]: BITOP with integer encoded source objects\r\n[ok]: BITOP with non string source key\r\n[ok]: BITOP with empty string after non empty string (issue #529)\r\n[ok]: BITPOS bit=0 with empty key returns 0\r\n[ok]: BITPOS bit=1 with empty key returns -1\r\n[ok]: BITPOS bit=0 with string less than 1 word works\r\n[ok]: BITPOS bit=1 with string less than 1 word works\r\n[ok]: BITPOS bit=0 starting at unaligned address\r\n[ok]: BITPOS bit=1 starting at unaligned address\r\n[ok]: BITPOS bit=0 unaligned+full word+reminder\r\n[ok]: BITPOS bit=1 unaligned+full word+reminder\r\n[ok]: BITPOS bit=1 returns -1 if string is all 0 bits\r\n[ok]: BITPOS bit=0 works with intervals\r\n[ok]: BITPOS bit=1 works with intervals\r\n[ok]: BITPOS bit=0 changes behavior if end is given\r\n[ok]: Test replication with blocking lists and sorted sets operations\r\n[ok]: BITPOS bit=1 fuzzy testing using SETBIT\r\n[37/64 done]: integration/psync2-pingoff (15 seconds)\r\nTesting unit/bitfield\r\n[ok]: Connect a replica to the master instance\r\n[ok]: Redis.replicate_commands() must be issued before any write\r\n[ok]: Redis.replicate_commands() must be issued before any write (2)\r\n[ok]: Redis.set_repl() must be issued after replicate_commands()\r\n[ok]: Redis.set_repl() don't accept invalid values\r\n[ok]: Test selective replication of certain Redis commands from Lua\r\n[ok]: PRNG is seeded randomly for command replication\r\n[ok]: Using side effects is not a problem with command replication\r\n[ok]: BITFIELD signed SET and GET basics\r\n[ok]: BITFIELD unsigned SET and GET basics\r\n[ok]: BITFIELD #<idx> form\r\n[ok]: BITFIELD basic INCRBY form\r\n[ok]: BITFIELD chaining of multiple commands\r\n[ok]: BITFIELD unsigned overflow wrap\r\n[ok]: BITFIELD unsigned overflow sat\r\n[ok]: BITFIELD signed overflow wrap\r\n[ok]: BITFIELD signed overflow sat\r\n[ok]: BITPOS bit=0 fuzzy testing using SETBIT\r\n[38/64 done]: integration/block-repl (26 seconds)\r\nTesting unit/geo\r\n[39/64 done]: unit/bitops (4 seconds)\r\nTesting unit/memefficiency\r\n[ok]: GEOADD create\r\n[ok]: GEOADD update\r\n[ok]: GEOADD update with CH option\r\n[ok]: GEOADD update with NX option\r\n[ok]: GEOADD update with XX option\r\n[ok]: GEOADD update with CH NX option\r\n[ok]: GEOADD update with CH XX option\r\n[ok]: GEOADD update with XX NX option will return syntax error\r\n[ok]: GEOADD update with invalid option\r\n[ok]: GEOADD invalid coordinates\r\n[ok]: GEOADD multi add\r\n[ok]: Check geoset values\r\n[ok]: GEORADIUS simple (sorted)\r\n[ok]: GEOSEARCH simple (sorted)\r\n[ok]: GEOSEARCH FROMLONLAT and FROMMEMBER cannot exist at the same time\r\n[ok]: GEOSEARCH FROMLONLAT and FROMMEMBER one must exist\r\n[ok]: GEOSEARCH BYRADIUS and BYBOX cannot exist at the same time\r\n[ok]: GEOSEARCH BYRADIUS and BYBOX one must exist\r\n[ok]: GEOSEARCH with STOREDIST option\r\n[ok]: GEORADIUS withdist (sorted)\r\n[ok]: GEOSEARCH withdist (sorted)\r\n[ok]: GEORADIUS with COUNT\r\n[ok]: GEORADIUS with ANY not sorted by default\r\n[ok]: GEORADIUS with ANY sorted by ASC\r\n[ok]: GEORADIUS with ANY but no COUNT\r\n[ok]: GEORADIUS with COUNT but missing integer argument\r\n[ok]: GEORADIUS with COUNT DESC\r\n[ok]: GEORADIUS HUGE, issue #2767\r\n[ok]: GEORADIUSBYMEMBER simple (sorted)\r\n[ok]: GEOSEARCH FROMMEMBER simple (sorted)\r\n[ok]: GEOSEARCH vs GEORADIUS\r\n[ok]: GEOSEARCH non square, long and narrow\r\n[ok]: GEOSEARCH corner point test\r\n[ok]: GEORADIUSBYMEMBER withdist (sorted)\r\n[ok]: GEOHASH is able to return geohash strings\r\n[ok]: GEOPOS simple\r\n[ok]: GEOPOS missing element\r\n[ok]: GEODIST simple & unit\r\n[ok]: GEODIST missing elements\r\n[ok]: GEORADIUS STORE option: syntax error\r\n[ok]: GEOSEARCHSTORE STORE option: syntax error\r\n[ok]: GEORANGE STORE option: incompatible options\r\n[ok]: GEORANGE STORE option: plain usage\r\n[ok]: GEOSEARCHSTORE STORE option: plain usage\r\n[ok]: GEORANGE STOREDIST option: plain usage\r\n[ok]: GEOSEARCHSTORE STOREDIST option: plain usage\r\n[ok]: GEORANGE STOREDIST option: COUNT ASC and DESC\r\n[ok]: GEOSEARCH the box spans -180° or 180°\r\n[ok]: BITFIELD overflow detection fuzzing\r\n[ok]: TOUCH alters the last access time of a key\r\n[ok]: TOUCH returns the number of existing keys specified\r\n[ok]: command stats for GEOADD\r\n[ok]: command stats for EXPIRE\r\n[ok]: command stats for BRPOP\r\n[ok]: command stats for MULTI\r\n[ok]: command stats for scripts\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[40/64 done]: unit/scripting (11 seconds)\r\nTesting unit/hyperloglog\r\n[41/64 done]: unit/introspection-2 (6 seconds)\r\nTesting unit/lazyfree\r\n[ok]: BITFIELD overflow wrap fuzzing\r\n[ok]: BITFIELD regression for #3221\r\n[ok]: BITFIELD regression for #3564\r\n[ok]: Memory efficiency with values in range 32\r\n[ok]: BITFIELD: setup slave\r\n[ok]: BITFIELD: write on master, read on slave\r\n[ok]: BITFIELD_RO fails when write option is used\r\n[ok]: UNLINK can reclaim memory in background\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[42/64 done]: unit/bitfield (2 seconds)\r\nTesting unit/wait\r\n[ok]: FLUSHDB ASYNC can reclaim memory in background\r\n[ok]: Memory efficiency with values in range 64\r\n[43/64 done]: unit/lazyfree (2 seconds)\r\nTesting unit/pendingquerybuf\r\n[ok]: Setup slave\r\n[ok]: WAIT should acknowledge 1 additional copy of the data\r\n[ok]: Fuzzer corrupt restore payloads - sanitize_dump: yes\r\n[44/64 done]: integration/corrupt-dump-fuzzer (20 seconds)\r\nTesting unit/tls\r\n[ok]: Memory efficiency with values in range 128\r\n[ok]: HyperLogLog self test passes\r\n[ok]: PFADD without arguments creates an HLL value\r\n[ok]: Approximated cardinality after creation is zero\r\n[ok]: PFADD returns 1 when at least 1 reg was modified\r\n[ok]: PFADD returns 0 when no reg was modified\r\n[ok]: PFADD works with empty string (regression)\r\n[ok]: PFCOUNT returns approximated cardinality of set\r\n[45/64 done]: unit/tls (0 seconds)\r\nTesting unit/tracking\r\n[ok]: Clients are able to enable tracking and redirect it\r\n[ok]: The other connection is able to get invalidations\r\n[ok]: The client is now able to disable tracking\r\n[ok]: Clients can enable the BCAST mode with the empty prefix\r\n[ok]: The connection gets invalidation messages about all the keys\r\n[ok]: Clients can enable the BCAST mode with prefixes\r\n[ok]: Adding prefixes to BCAST mode works\r\n[ok]: Tracking NOLOOP mode in standard mode works\r\n[ok]: Tracking NOLOOP mode in BCAST mode works\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 91881)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 4 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #4 as master\r\n[ok]: PSYNC2: Set #2 to replicate from #4\r\n[ok]: PSYNC2: Set #3 to replicate from #4\r\n[ok]: PSYNC2: Set #1 to replicate from #3\r\n[ok]: PSYNC2: Set #0 to replicate from #4\r\n[ok]: Memory efficiency with values in range 1024\r\n[ok]: HyperLogLogs are promote from sparse to dense\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: WAIT should not acknowledge 2 additional copies of the data\r\n[ok]: Tracking gets notification of expired keys\r\n[ok]: HELLO 3 reply is correct\r\n[ok]: HELLO without protover\r\n[ok]: RESP3 based basic invalidation\r\n[ok]: RESP3 tracking redirection\r\n[ok]: Invalidations of previous keys can be redirected after switching to RESP3\r\n[ok]: Invalidations of new keys can be redirected after switching to RESP3\r\n[ok]: RESP3 Client gets tracking-redir-broken push message after cached key changed when rediretion client is terminated\r\n[ok]: Different clients can redirect to the same connection\r\n[ok]: Different clients using different protocols can track the same key\r\n[ok]: No invalidation message when using OPTIN option\r\n[ok]: Invalidation message sent when using OPTIN option with CLIENT CACHING yes\r\n[ok]: Invalidation message sent when using OPTOUT option\r\n[ok]: No invalidation message when using OPTOUT option with CLIENT CACHING no\r\n[ok]: Able to redirect to a RESP3 client\r\n[ok]: After switching from normal tracking to BCAST mode, no invalidation message is produced for pre-BCAST keys\r\n[ok]: BCAST with prefix collisions throw errors\r\n[ok]: Tracking gets notification on tracking table key eviction\r\n[ok]: Invalidation message received for flushall\r\n[ok]: Invalidation message received for flushdb\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: HyperLogLog sparse encoding stress test\r\n[ok]: Corrupted sparse HyperLogLogs are detected: Additional at tail\r\n[ok]: Corrupted sparse HyperLogLogs are detected: Broken magic\r\n[ok]: Corrupted sparse HyperLogLogs are detected: Invalid encoding\r\n[ok]: Corrupted dense HyperLogLogs are detected: Wrong length\r\n[ok]: Server is able to evacuate enough keys when num of keys surpasses limit by more than defined initial effort\r\n[ok]: Tracking info is correct\r\n[ok]: CLIENT GETREDIR provides correct client id\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking off\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking on\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking on with options\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking optin\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking optout\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking bcast mode\r\n[ok]: CLIENT TRACKINGINFO provides reasonable results when tracking redir broken\r\n[ok]: Memory efficiency with values in range 16384\r\n[46/64 done]: unit/tracking (1 seconds)\r\nTesting unit/oom-score-adj\r\n[ok]: PSYNC2 #3899 regression: kill chained replica\r\n[ok]: CONFIG SET oom-score-adj works as expected\r\n[47/64 done]: unit/memefficiency (4 seconds)\r\nTesting unit/shutdown\r\n[ok]: WAIT should not acknowledge 1 additional copy if slave is blocked\r\n[ok]: Temp rdb will be deleted if we use bg_unlink when shutdown\r\n[ok]: Temp rdb will be deleted in signal handle\r\n[48/64 done]: unit/shutdown (0 seconds)\r\nTesting unit/networking\r\n[ok]: MASTER and SLAVE consistency with EVALSHA replication\r\n[ok]: CONFIG SET port number\r\n[ok]: Test replication partial resync: ok after delay (diskless: no, disabled, reconnect: 1)\r\n[err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\n[49/64 done]: unit/networking (1 seconds)\r\n[50/64 done]: unit/oom-score-adj (2 seconds)\r\n[ok]: WAIT implicitly blocks on client pause since ACKs aren't sent\r\n[ok]: PSYNC2 #3899 regression: verify consistency\r\n[51/64 done]: unit/wait (4 seconds)\r\n[ok]: Slave should be able to synchronize with the master\r\n[52/64 done]: integration/psync2-reg (22 seconds)\r\n[ok]: Detect write load to master\r\n[ok]: pending querybuf: check size of pending_querybuf after set a big value\r\n[ok]: SLAVE can reload \"lua\" AUX RDB fields of duplicated scripts\r\n[53/64 done]: unit/pendingquerybuf (6 seconds)\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 125895)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 5 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #0 as master\r\n[ok]: PSYNC2: Set #2 to replicate from #0\r\n[ok]: PSYNC2: Set #4 to replicate from #2\r\n[ok]: PSYNC2: Set #3 to replicate from #2\r\n[ok]: PSYNC2: Set #1 to replicate from #3\r\n[54/64 done]: integration/replication-3 (34 seconds)\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: Client output buffer hard limit is enforced\r\n[ok]: Replication: commands with many arguments (issue #1221)\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 190238)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 6 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #4 as master\r\n[ok]: PSYNC2: Set #3 to replicate from #4\r\n[ok]: PSYNC2: Set #1 to replicate from #4\r\n[ok]: PSYNC2: Set #2 to replicate from #3\r\n[ok]: PSYNC2: Set #0 to replicate from #2\r\n[ok]: Replication of SPOP command -- alsoPropagate() API\r\n[55/64 done]: integration/replication-4 (40 seconds)\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: Test replication partial resync: backlog expired (diskless: no, disabled, reconnect: 1)\r\n[ok]: Client output buffer soft limit is not enforced if time is not overreached\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no reconnection, just sync (diskless: no, swapdb, reconnect: 0)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: slave buffer are counted correctly\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 257556)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: PSYNC2: --- CYCLE 7 ---\r\n[ok]: PSYNC2: [NEW LAYOUT] Set #0 as master\r\n[ok]: PSYNC2: Set #1 to replicate from #0\r\n[ok]: PSYNC2: Set #2 to replicate from #1\r\n[ok]: PSYNC2: Set #3 to replicate from #2\r\n[ok]: PSYNC2: Set #4 to replicate from #0\r\n[ok]: PSYNC2: cluster is consistent after failover\r\n[ok]: Client output buffer soft limit is enforced if time is overreached\r\n[ok]: No response for single command if client output buffer hard limit is enforced\r\n[ok]: No response for multi commands in pipeline if client output buffer limit is enforced\r\n[ok]: Execute transactions completely even if client output buffer limit is enforced\r\n[56/64 done]: unit/obuf-limits (27 seconds)\r\n[ok]: AOF rewrite during write load: RDB preamble=no\r\n[ok]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=disabled\r\n[ok]: Turning off AOF kills the background writing child if any\r\n[ok]: replica buffer don't induce eviction\r\n[ok]: PSYNC2: generate load while killing replication links\r\n[ok]: PSYNC2: cluster is consistent after load (x = 310403)\r\n[ok]: PSYNC2: total sum of full synchronizations is exactly 4\r\n[ok]: Test replication partial resync: ok psync (diskless: no, swapdb, reconnect: 1)\r\n[ok]: AOF rewrite of list with quicklist encoding, string data\r\n[ok]: GEOSEARCH fuzzy test - byradius\r\n[ok]: Don't rehash if used memory exceeds maxmemory after rehash\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: PSYNC2: Bring the master back again for next test\r\n[ok]: PSYNC2: Partial resync after restart using RDB aux fields\r\n[ok]: AOF rewrite of list with quicklist encoding, int data\r\n[ok]: Detect write load to master\r\n[ok]: client tracking don't cause eviction feedback loop\r\n[57/64 done]: unit/maxmemory (36 seconds)\r\n[ok]: PSYNC2: Replica RDB restart with EVALSHA in backlog issue #4483\r\n[ok]: AOF rewrite of set with intset encoding, string data\r\n[58/64 done]: integration/psync2 (44 seconds)\r\n[ok]: AOF rewrite of set with hashtable encoding, string data\r\n[ok]: AOF rewrite of set with intset encoding, int data\r\n[ok]: AOF rewrite of set with hashtable encoding, int data\r\n[ok]: AOF rewrite of hash with ziplist encoding, string data\r\n[ok]: AOF rewrite of hash with hashtable encoding, string data\r\n[ok]: AOF rewrite of hash with ziplist encoding, int data\r\n[ok]: AOF rewrite of hash with hashtable encoding, int data\r\n[ok]: Test replication partial resync: no backlog (diskless: no, swapdb, reconnect: 1)\r\n[ok]: AOF rewrite of zset with ziplist encoding, string data\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: AOF rewrite of zset with skiplist encoding, string data\r\n[ok]: AOF rewrite of zset with ziplist encoding, int data\r\n[ok]: AOF rewrite of zset with skiplist encoding, int data\r\n[ok]: BGREWRITEAOF is delayed if BGSAVE is in progress\r\n[ok]: BGREWRITEAOF is refused if already in progress\r\n[59/64 done]: unit/aofrw (71 seconds)\r\n[ok]: GEOSEARCH fuzzy test - bybox\r\n[ok]: GEOSEARCH box edges fuzzy test\r\n[60/64 done]: north (43 seconds)\r\n[ok]: Fuzzing dense/sparse encoding: Redis should always detect errors\r\n[ok]: PFADD, PFCOUNT, PFMERGE type checking works\r\n[ok]: PFMERGE results on the cardinality of union of sets\r\n[ok]: Test replication partial resync: ok after delay (diskless: no, swapdb, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Stress tester for #3343-alike bugs\r\n[ok]: PFCOUNT multiple-keys merge returns cardinality of union #1\r\n[ok]: PFCOUNT multiple-keys merge returns cardinality of union #2\r\n[ok]: PFDEBUG GETREG returns the HyperLogLog raw registers\r\n[ok]: PFADD / PFCOUNT cache invalidation works\r\n[61/64 done]: unit/hyperloglog (53 seconds)\r\n[ok]: Test replication partial resync: backlog expired (diskless: no, swapdb, reconnect: 1)\r\n[ok]: ziplist implementation: value encoding and backlink\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no reconnection, just sync (diskless: yes, disabled, reconnect: 0)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=swapdb\r\n[ok]: ziplist implementation: encoding stress testing\r\n[62/64 done]: unit/type/list-3 (98 seconds)\r\n[ok]: Test replication partial resync: ok psync (diskless: yes, disabled, reconnect: 1)\r\nWaiting for process 11961 to exit...\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no backlog (diskless: yes, disabled, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: ok after delay (diskless: yes, disabled, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: backlog expired (diskless: yes, disabled, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no reconnection, just sync (diskless: yes, swapdb, reconnect: 0)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=disabled\r\n[ok]: Test replication partial resync: ok psync (diskless: yes, swapdb, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: no backlog (diskless: yes, swapdb, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: ok after delay (diskless: yes, swapdb, reconnect: 1)\r\n[ok]: Slave should be able to synchronize with the master\r\n[ok]: Detect write load to master\r\n[ok]: Test replication partial resync: backlog expired (diskless: yes, swapdb, reconnect: 1)\r\n[63/64 done]: integration/replication-psync (172 seconds)\r\n[ok]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=swapdb\r\n[ok]: Master stream is correctly processed while the replica has a script in -BUSY state\r\n[ok]: slave fails full sync and diskless load swapdb recovers it\r\n[ok]: diskless loading short read\r\n[ok]: diskless no replicas drop during rdb pipe\r\n[ok]: diskless slow replicas drop during rdb pipe\r\n[ok]: diskless fast replicas drop during rdb pipe\r\n[ok]: diskless all replicas drop during rdb pipe\r\n[ok]: diskless timeout replicas drop during rdb pipe\r\n[ok]: diskless replication child being killed is collected\r\n[ok]: replicaof right after disconnection\r\n[ok]: Kill rdb child process if its dumping RDB is not useful\r\n[64/64 done]: integration/replication (257 seconds)\r\nTesting solo test\r\n[ok]: Active defrag\r\n[ok]: Active defrag big keys\r\n[ok]: Active defrag big list\r\n[ok]: Active defrag edge case\r\n[64/64 done]: defrag (98 seconds)\r\n\r\n                   The End\r\n\r\nExecution time of different units:\r\n  1 seconds - unit/printver\r\n  1 seconds - unit/type/incr\r\n  1 seconds - unit/info\r\n  1 seconds - unit/protocol\r\n  2 seconds - unit/keyspace\r\n  2 seconds - unit/auth\r\n  0 seconds - unit/quit\r\n  5 seconds - unit/type/hash\r\n  4 seconds - unit/multi\r\n  6 seconds - unit/type/set\r\n  5 seconds - unit/type/stream-cgroups\r\n  5 seconds - unit/sort\r\n  2 seconds - unit/acl\r\n  8 seconds - unit/type/list\r\n  8 seconds - unit/scan\r\n  8 seconds - unit/type/string\r\n  11 seconds - unit/other\r\n  12 seconds - unit/type/list-2\r\n  9 seconds - unit/latency-monitor\r\n  10 seconds - integration/replication-2\r\n  8 seconds - integration/aof\r\n  1 seconds - integration/convert-zipmap-hash-on-load\r\n  16 seconds - unit/expire\r\n  17 seconds - unit/type/zset\r\n  1 seconds - integration/logging\r\n  7 seconds - integration/rdb\r\n  8 seconds - integration/corrupt-dump\r\n  2 seconds - integration/redis-benchmark\r\n  5 seconds - integration/failover\r\n  0 seconds - unit/pubsub\r\n  2 seconds - unit/slowlog\r\n  26 seconds - unit/dump\r\n  8 seconds - integration/redis-cli\r\n  28 seconds - unit/type/stream\r\n  2 seconds - unit/introspection\r\n  1 seconds - unit/limits\r\n  15 seconds - integration/psync2-pingoff\r\n  26 seconds - integration/block-repl\r\n  4 seconds - unit/bitops\r\n  11 seconds - unit/scripting\r\n  6 seconds - unit/introspection-2\r\n  2 seconds - unit/bitfield\r\n  2 seconds - unit/lazyfree\r\n  20 seconds - integration/corrupt-dump-fuzzer\r\n  0 seconds - unit/tls\r\n  1 seconds - unit/tracking\r\n  4 seconds - unit/memefficiency\r\n  0 seconds - unit/shutdown\r\n  1 seconds - unit/networking\r\n  2 seconds - unit/oom-score-adj\r\n  4 seconds - unit/wait\r\n  22 seconds - integration/psync2-reg\r\n  6 seconds - unit/pendingquerybuf\r\n  34 seconds - integration/replication-3\r\n  40 seconds - integration/replication-4\r\n  27 seconds - unit/obuf-limits\r\n  36 seconds - unit/maxmemory\r\n  44 seconds - integration/psync2\r\n  71 seconds - unit/aofrw\r\n  43 seconds - north\r\n  53 seconds - unit/hyperloglog\r\n  98 seconds - unit/type/list-3\r\n  172 seconds - integration/replication-psync\r\n  257 seconds - integration/replication\r\n  98 seconds - defrag\r\n\r\n!!! WARNING The following tests failed:\r\n\r\n*** [err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\nCleanup: may take some time... OK\r\nMakefile:387: recipe for target 'test' failed\r\nmake[1]: *** [test] Error 1\r\nmake[1]: Leaving directory '/tmp/redis-stable/src'\r\nMakefile:6: recipe for target 'test' failed\r\nmake: *** [test] Error 2\r\n\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>Output of `./runtest --single unit/networking`</summary>\r\n\r\n```\r\nCleanup: may take some time... OK\r\nStarting test server at port 21079\r\n[ready]: 16821\r\nTesting unit/networking\r\n[ready]: 16822\r\n[ready]: 16823\r\n[ready]: 16824\r\n[ready]: 16825\r\n[ready]: 16826\r\n[ready]: 16827\r\n[ready]: 16828\r\n[ready]: 16830\r\n[ready]: 16829\r\n[ready]: 16831\r\n[ready]: 16832\r\n[ready]: 16833\r\n[ready]: 16834\r\n[ready]: 16835\r\n[ready]: 16836\r\n[ok]: CONFIG SET port number\r\n[err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\n[1/1 done]: unit/networking (1 seconds)\r\n\r\n                   The End\r\n\r\nExecution time of different units:\r\n  1 seconds - unit/networking\r\n\r\n!!! WARNING The following tests failed:\r\n\r\n*** [err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\nCleanup: may take some time... OK\r\n\r\n```\r\n</details>",
  "state": "closed",
  "created_at": "2021-04-20T12:25:59Z",
  "updated_at": "2021-04-27T15:09:49Z",
  "closed_at": "2021-04-27T15:09:49Z",
  "labels": [],
  "comments_data": [
    {
      "id": 823237477,
      "user": "sundb",
      "created_at": "2021-04-20T12:35:39Z",
      "body": "Have you checked if your host file is abnormal? You can ```ping some.wrong.bind.address``` to see what it returns."
    },
    {
      "id": 823239952,
      "user": "stefanschindler",
      "created_at": "2021-04-20T12:39:34Z",
      "body": "@sundb \r\n\r\nthanks for your response. In my opinion, my /etc/hosts looks good. And the same as on the other servers:\r\n\r\n```\r\n127.0.0.1 localhost.localdomain localhost\r\n::1     localhost.localdomain localhost ip6-localhost ip6-loopback\r\nff02::1 ip6-allnodes\r\nff02::2 ip6-allrouters\r\n\r\n# Auto-generated hostname. Please do not remove this comment.\r\n<server-ip> lvps<server-ip>.dedicated.hosteurope.de lvps<server-ip>\r\n```\r\n\r\n`ping` produces the following response:\r\n\r\n```\r\nPING some.wrong.bind.address.cambuildr.com (<server-ip>) 56(84) bytes of data.\r\n64 bytes from lvps<server-ip>.dedicated.hosteurope.de (<server-ip>): icmp_seq=1 ttl=64 time=0.044 ms\r\n64 bytes from lvps<server-ip>.dedicated.hosteurope.de (<server-ip>): icmp_seq=2 ttl=64 time=0.043 ms\r\n```\r\n"
    },
    {
      "id": 823245552,
      "user": "sundb",
      "created_at": "2021-04-20T12:48:05Z",
      "body": "Feel that your dns has problem. "
    },
    {
      "id": 823246609,
      "user": "sundb",
      "created_at": "2021-04-20T12:49:21Z",
      "body": "```cat /etc/resolv.conf``` What to Output?"
    },
    {
      "id": 823247354,
      "user": "stefanschindler",
      "created_at": "2021-04-20T12:50:27Z",
      "body": "It says \r\n\r\n```\r\n# This file is managed by man:systemd-resolved(8). Do not edit.\r\n#\r\n# This is a dynamic resolv.conf file for connecting local clients to the\r\n# internal DNS stub resolver of systemd-resolved. This file lists all\r\n# configured search domains.\r\n#\r\n# Run \"systemd-resolve --status\" to see details about the uplink DNS servers\r\n# currently in use.\r\n#\r\n# Third party programs must not access this file directly, but only through the\r\n# symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,\r\n# replace this symlink by a static file or a different symlink.\r\n#\r\n# See man:systemd-resolved.service(8) for details about the supported modes of\r\n# operation for /etc/resolv.conf.\r\n\r\nnameserver 127.0.0.53\r\noptions edns0\r\n```"
    },
    {
      "id": 823248756,
      "user": "sundb",
      "created_at": "2021-04-20T12:52:41Z",
      "body": "```nslookup some.wrong.bind.address``` Once again."
    },
    {
      "id": 823250019,
      "user": "stefanschindler",
      "created_at": "2021-04-20T12:54:29Z",
      "body": "```\r\nnslookup some.wrong.bind.address\r\nServer:\t\t127.0.0.53\r\nAddress:\t127.0.0.53#53\r\n\r\n** server can't find some.wrong.bind.address: NXDOMAIN\r\n\r\n```"
    },
    {
      "id": 823252511,
      "user": "sundb",
      "created_at": "2021-04-20T12:58:07Z",
      "body": "You can try commenting ```<server-ip> lvps<server-ip>.dedicated.hosteurope.de lvps<server-ip>```, it feels like there is something wrong with this configuration."
    },
    {
      "id": 823255228,
      "user": "stefanschindler",
      "created_at": "2021-04-20T13:01:51Z",
      "body": "Unfortunately that didn't have any effect\r\n\r\n```\r\n./runtest --single unit/networking\r\nCleanup: may take some time... OK\r\nStarting test server at port 21079\r\n[ready]: 18362\r\nTesting unit/networking\r\n[ready]: 18363\r\n[ready]: 18361\r\n[ready]: 18364\r\n[ready]: 18366\r\n[ready]: 18365\r\n[ready]: 18367\r\n[ready]: 18368\r\n[ready]: 18369\r\n[ready]: 18371\r\n[ready]: 18370\r\n[ready]: 18373\r\n[ready]: 18372\r\n[ready]: 18374\r\n[ready]: 18375\r\n[ready]: 18376\r\n[ok]: CONFIG SET port number\r\n[err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\n[1/1 done]: unit/networking (0 seconds)\r\n\r\n                   The End\r\n\r\nExecution time of different units:\r\n  0 seconds - unit/networking\r\n\r\n!!! WARNING The following tests failed:\r\n\r\n*** [err]: CONFIG SET bind address in tests/unit/networking.tcl\r\nExpected 'OK' to match '*Failed to bind to specified addresses*' (context: type eval line 4 cmd {assert_match {*Failed to bind to specified addresses*} $e} proc ::start_server)\r\nCleanup: may take some time... OK\r\n```"
    },
    {
      "id": 823261555,
      "user": "sundb",
      "created_at": "2021-04-20T13:10:45Z",
      "body": "You can ping ```some.wrong.bind.address``` through to cause redis can bind successfully and cause the test to fail, I can not be sure where the problem."
    },
    {
      "id": 823826045,
      "user": "stefanschindler",
      "created_at": "2021-04-21T06:57:55Z",
      "body": "sorry, what do you mean by \"pinging through\"?"
    },
    {
      "id": 823829396,
      "user": "sundb",
      "created_at": "2021-04-21T07:04:36Z",
      "body": "Normal conditions.\r\n```\r\nping some.wrong.bind.address\r\nping: some.wrong.bind.address: No address associated with hostname\r\n```\r\n\r\nBut you can ping the address, and bind the address in the test are successful, so the test will fail.\r\n"
    },
    {
      "id": 824058829,
      "user": "huangzhw",
      "created_at": "2021-04-21T13:25:01Z",
      "body": "Like your machine auto add `cambuildr.com` to domain. "
    }
  ]
}