{
  "issue_number": 8937.0,
  "title": "[BUG] Potential data race in showThroughput function in redis-benchmark",
  "body": "**Describe the bug**\r\n\r\nWe found a potential data race on [`config.previous_tick`][racevar] in redis-benchmark using a static analysis tool.\r\n\r\nWe are not 100% sure this is a real race, but after manually reviewing the report it looks potentially real so we decided to open this issue just in case.\r\n\r\n**To reproduce**\r\n\r\nThe race occurs if two threads are able to call [`showThroughput`][racefunc] in parallel.\r\n\r\nhttps://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L1648-L1650\r\n\r\n`config.previous_tick` is read at line 1648 and written to at 1650. If this function can be executed in parallel these accesses could cause a data race.\r\n\r\nThreads spawned by [`startBenchmarkThreads`][1] can call:\r\n\r\n[`execBenchmarkThread`][2] -> [`aeMain`][3] -> [`aeProcessEvents`][4] -> [`processTimeEvents`][5].\r\n\r\nInside of `processTimeEvents` the function pointer [`te->timeProc`][6] is called.\r\n\r\nhttps://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/ae.c#L319\r\n\r\nOur analysis shows that `te->timeProc` can resolve to `showThroughput`. If this is true multiple threads may execute `showThroughput` in parallel causing a data race on `config.previous_tick`.\r\n\r\nIt looks like when benchmark threads are created, a time event is added where `timeProc` is set to `showThroughput`, but I am not sure about any future time events.\r\n\r\nhttps://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L1018-L1024\r\n\r\n\r\n[racevar]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L95\r\n[racefunc]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L1620\r\n[1]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L965\r\n[2]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L969\r\n[3]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/redis-benchmark.c#L1044\r\n[4]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/ae.c#L488\r\n[5]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/ae.c#L458\r\n[6]: https://github.com/redis/redis/blob/e01c92a5ef6127067922f74cd8dac2ba72a1ad52/src/ae.c#L319\r\n\r\n**Expected behavior**\r\n\r\nIf the data race can occur, should the access to `config.previous_tick` be made atomic?\r\n\r\n**Additional information**\r\n\r\nFor reference I've pasted the report from our tool below:\r\n\r\n```c\r\n==== Found a race between: \r\nline 1650, column 5 in redis-benchmark.c AND line 1648, column 64 in redis-benchmark.c\r\nStatic variable: \r\nconfig at line 130 of redis-benchmark.c\r\n 130|} config;\r\nshared field: ->previous_tick\r\nThread 1 (write): \r\n 1648|    const float instantaneous_dt = (float)(current_tick-config.previous_tick)/1000.0;\r\n 1649|    const float instantaneous_rps = (float)(requests_finished-previous_requests_finished)/instantaneous_dt;\r\n>1650|    config.previous_tick = current_tick;\r\n 1651|    atomicSet(config.previous_requests_finished,requests_finished);\r\n 1652|    int printed_bytes = printf(\"%s: rps=%.1f (overall: %.1f) avg_msec=%.3f (overall: %.3f)\\r\", config.title, instantaneous_rps, rps, hdr_mean(config.current_sec_latency_histogram)/1000.0f, hdr_mean(config.latency_histogram)/1000.0f);\r\n>>>Stack Trace:\r\n>>>main\r\n>>>  startBenchmarkThreads [redis-benchmark.c:1800]\r\n>>>    pthread_create [redis-benchmark.c:969]\r\n>>>      execBenchmarkThread [redis-benchmark.c:969]\r\n>>>        aeMain [redis-benchmark.c:1044]\r\n>>>          aeProcessEvents [ae.c:488]\r\n>>>            processTimeEvents [ae.c:458]\r\n>>>              showThroughput [ae.c:319]\r\nThread 2 (read): \r\n 1646|    const float dt = (float)(current_tick-config.start)/1000.0;\r\n 1647|    const float rps = (float)requests_finished/dt;\r\n>1648|    const float instantaneous_dt = (float)(current_tick-config.previous_tick)/1000.0;\r\n 1649|    const float instantaneous_rps = (float)(requests_finished-previous_requests_finished)/instantaneous_dt;\r\n 1650|    config.previous_tick = current_tick;\r\n>>>Stack Trace:\r\n>>>main\r\n>>>  startBenchmarkThreads [redis-benchmark.c:1800]\r\n>>>    pthread_create [redis-benchmark.c:969]\r\n>>>      execBenchmarkThread [redis-benchmark.c:969]\r\n>>>        aeMain [redis-benchmark.c:1044]\r\n>>>          aeProcessEvents [ae.c:488]\r\n>>>            processTimeEvents [ae.c:458]\r\n>>>              showThroughput [ae.c:319]\r\n```\r\n",
  "state": "closed",
  "created_at": "2021-05-12T16:47:16Z",
  "updated_at": "2021-05-13T15:23:34Z",
  "closed_at": "2021-05-13T15:14:44Z",
  "labels": [],
  "comments_data": [
    {
      "id": 840237149,
      "user": "madolson",
      "created_at": "2021-05-13T02:16:10Z",
      "body": "It doesn't seem possible to me, I believe only one thread will ever be executing ```showThroughput()``` at a given time. Since this is the reporting thread, it doesn't need to be executed on multiple threads. "
    },
    {
      "id": 840630262,
      "user": "BradSwain",
      "created_at": "2021-05-13T15:14:44Z",
      "body": "We reviewed the report more closely and also found this to be a false positive.\r\nThank you for taking the time to review this issue even though this turned out to be a false report.\r\nWe appreciate your time and will be more careful about reporting issues in the future."
    }
  ]
}